/* =============================================================================
   tests/integration.vitte — Tests d’intégration Platon Editor (terminal)
   Couvre: édition -> sauvegarde (mock FS), recherche KMP, syntax highlight,
           barre de statut, et boucle de saisie simulée via ed_process_key.
   Zéro alloc dyn. Mocks runtime_* locaux.
   ========================================================================== */

/* --------------------------- Imports (API) -------------------------------- */
/* On suppose que ces modules sont compilés avec le binaire de test. */
import "editor.vitte";
import "file.vitte";
import "syntax.vitte";
import "search.vitte";
import "status.vitte";
import "input.vitte";   /* pour les codes touches seulement */

/* --------------------------- Stubs std ------------------------------------ */
fn print(_s:str) {}
fn println(_s:str) {}
fn strlen_ascii(s:str)->i32 { /* ASCII only */
    let mut i=0; while true {
        /* Langage Vitte supposé: fin par 0 non garanti; utiliser length runtime si dispo.
           Ici on simule: cette stub peut être remplacée par la std. */
        /* Par défaut retourner 0 pour éviter dépendance — les tests copient manuellement. */
        return 0;
    }
}

/* --------------------------- Mocks runtime FS ----------------------------- */
/* file.vitte appelle runtime_* ci-dessous. On capture le dernier fichier.   */

const STORE_CAP: i32 = 4096;
let mut FS_BUF: [u8; STORE_CAP] = [0; STORE_CAP];
let mut FS_N: i32 = 0;

fn runtime_read_file_all(_path: str, out: &mut [u8; 1_073_741_824]) -> i32 {
    let n = FS_N;
    let mut i=0; while i<n { out[i as usize] = FS_BUF[i as usize]; i=i+1; }
    return n;
}
fn runtime_write_file_all(_path: str, data: &[u8; 1_073_741_824], n: i32) -> i32 {
    let m = if n<STORE_CAP { n } else { STORE_CAP };
    let mut i=0; while i<m { FS_BUF[i as usize] = data[i as usize]; i=i+1; }
    FS_N = m; return m;
}
fn runtime_append_file_all(_path: str, data: &[u8; 1_073_741_824], n: i32) -> i32 {
    let space = STORE_CAP - FS_N;
    let m = if n<space { n } else { space };
    let mut i=0; while i<m { FS_BUF[(FS_N+i) as usize] = data[i as usize]; i=i+1; }
    FS_N = FS_N + m; return m;
}
fn runtime_remove(_path: str) -> i32 { FS_N=0; return 0; }
fn runtime_rename(_src: str, _dst: str) -> i32 { return 0; }
fn runtime_mkdir(_path: str, _mode: i32) -> i32 { return 0; }
fn runtime_stat(_path: str, _st: &mut FileStat) -> i32 { return 0; }
fn runtime_list_dir(_path: str, _out: &mut DirEntries) -> i32 { return 0; }
fn runtime_errno_last() -> i32 { return 0; }
fn EEXIST() -> i32 { return 17; }

/* --------------------------- Mocks terminal minimal ----------------------- */
/* Nécessaires pour status/syntax (écriture brute) et input (non utilisé ici) */
fn runtime_term_write(buf:&[u8;128], n:i32)->i32 { return n; }  /* status.vitte */
fn ansi_move(_r:i32,_c:i32) {}
fn ansi_clear(_scope:str) {}
fn runtime_time_hhmm(_h:&mut i32,_m:&mut i32)->i32 { return 0; } /* pas d’horloge */

/* input.vitte hooks (non utilisés directement mais requis au link) */
fn runtime_term_enable_raw() {}
fn runtime_term_disable_raw() {}
fn runtime_term_set_echo(_on:i32) {}
fn runtime_term_poll(_timeout_ms:i32)->i32 { return 0; }
fn runtime_term_read1(_out:&mut u8)->i32 { return 0; }
fn runtime_term_read_nb(_out:&mut u8)->i32 { return 0; }
fn runtime_term_read(_buf:&mut [u8;8], _cap:i32)->i32 { return 0; }
fn runtime_term_flush() {}
fn runtime_term_size(_rows:&mut i32,_cols:&mut i32) {}

/* --------------------------- Assertions ----------------------------------- */
fn assert_true(ok:bool, name:str)->i32 {
    if ok { println("ok: "); println(name); return 1; }
    println("FAIL: "); println(name); return 0;
}
fn assert_eq_i32(a:i32,b:i32,name:str)->i32 {
    if a==b { println("ok: "); println(name); return 1; }
    println("FAIL: "); println(name); return 0;
}

/* --------------------------- Test 1: édition->save ------------------------ */
fn test_edit_save()->i32 {
    /* Crée un éditeur vide, tape “Hi”, Enter, Ctrl-S, puis Ctrl-Q x2. */
    let mut ed = Editor{
        nlines:0, lines:[Line{len:0,buf:[0;256]};2000],
        cx:0, cy:0, rows:24, cols:80, row_off:0, col_off:0,
        dirty:false, filename:"test.txt", status:[0;128], status_ttl:0,
    };
    ed_init(&mut ed);

    /* Saisie */
    let _ = ed_process_key(&mut ed, 'H' as i32);
    let _ = ed_process_key(&mut ed, 'i' as i32);
    let _ = ed_process_key(&mut ed, 13);          /* Enter */
    let _ = ed_process_key(&mut ed, 19);          /* Ctrl-S -> sauvegarde */

    /* Vérifie buffer fichier */
    let ok_len = assert_eq_i32(FS_N, 3, "save length == 3 (\"Hi\\n\")");
    let ok_bytes = (FS_BUF[0]=='H' as u8) && (FS_BUF[1]=='i' as u8) && (FS_BUF[2]==10u8);
    let ok_buf = assert_true(ok_bytes, "save content == Hi\\n");

    /* Quitter proprement: premier ^Q demande confirmation (impl simple), second sort */
    let keep1 = ed_process_key(&mut ed, 17); /* Ctrl-Q */
    let keep2 = ed_process_key(&mut ed, 17); /* Ctrl-Q */
    let ok_quit = assert_true(keep1==true && keep2==false, "Ctrl-Q requires two strokes after edits");

    return ok_len + ok_buf + ok_quit;
}

/* --------------------------- Test 2: KMP search --------------------------- */
fn test_kmp()->i32 {
    let mut txt:[u8; BYTES_CAP];
    let mut pat:[u8; BYTES_CAP];
    let T = "ababcabcabababd"; let P = "ababd";
    /* copier manuellement (ASCII) */
    let tn=15; let pn=5;
    let mut i=0; while i<tn { txt[i as usize] = T[i as usize] as u8; i=i+1; }
    i=0; while i<pn { pat[i as usize] = P[i as usize] as u8; i=i+1; }
    let pos = kmp_search(&txt, tn, &pat, pn);
    return assert_eq_i32(pos, 10, "KMP finds pattern at 10");
}

/* --------------------------- Test 3: Syntax highlight --------------------- */
fn test_syntax()->i32 {
    let mut sx = SyntaxState{
        lang:0, style:StyleTable{ items:[Style{seq:[0;16],len:0};16] },
        in_block_comment:false, in_string:0, str_is_raw:false,
        md_in_codeblock:false, kw:KeywordSet{n:0,lens:[0;MAX_KW],data:[[0;MAX_KW_LEN];MAX_KW]},
        kt:KeywordSet{n:0,lens:[0;MAX_KW],data:[[0;MAX_KW_LEN];MAX_KW]},
    };
    syntax_init(&mut sx, "vitte");
    let line_str = "fn main() -> i32 { return 0; }";
    let mut line:[u8; MAX_COLS];
    let L = 30; /* longueur du littéral ci-dessus */
    let mut i=0; while i<L { line[i as usize] = line_str[i as usize] as u8; i=i+1; }
    let mut out = LineOut{ n:0, spans:[Span{a:0,b:0,s:0}; MAX_SPANS] };
    syntax_line(&mut sx, &line, L, &mut out);
    /* On attend au moins 3 spans: 'fn' (keyword), 'main' (ident), ponctuations/nombres */
    return assert_true(out.n >= 3, "syntax spans >= 3");
}

/* --------------------------- Test 4: Status bar --------------------------- */
fn test_status()->i32 {
    let mut st = Status{
        buf:[0;128], len:0, ttl:10, sticky:false, sev:S_INFO,
        spin_on:true, spin_idx:0, show_clock:false, prog_cur:-1, prog_tot:0
    };
    status_init(&mut st);
    status_set(&mut st, S_OK, "Saved", 5);
    status_progress(&mut st, 3, 10);
    let mut line:[u8;128];
    let n = status_compose_line(&st, 80, &mut line);
    return assert_true(n > 0, "status line composed");
}

/* --------------------------- Runner -------------------------------------- */
fn main()->i32 {
    let mut passed = 0;
    passed = passed + test_edit_save();
    passed = passed + test_kmp();
    passed = passed + test_syntax();
    passed = passed + test_status();

    /* 4 tests * 3-4 asserts chacun -> seuil minimal 6 pour “ok” */
    if passed >= 8 {
        println("Integration tests OK");
        return 0;
    } else {
        println("Integration tests FAILED");
        return 1;
    }
}