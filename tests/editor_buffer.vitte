/* ============================================================================
   tests/editor_buffer.vitte — Tests unitaires buffer éditeur (Platon Editor)
   Vérifie:
     - insertion/suppression de caractères et lignes
     - lecture/écriture dans Editor
     - cohérence dirty flag, longueur lignes
   ============================================================================ */

import "editor.vitte";

/* stubs std */
fn println(s:str){}
fn println_i32(x:i32){}
fn assert_eq_i32(a:i32,b:i32,msg:str){
    if a!=b { println("FAIL: "); println(msg); println_i32(a); }
}
fn assert_true(cond:bool,msg:str){
    if !cond { println("FAIL: "); println(msg); }
}

/* Test insertion caractère */
fn test_insert_char()->bool{
    let mut ed=Editor{
        nlines:0, lines:[Line{len:0,buf:[0;256]};2000],
        cx:0,cy:0,rows:24,cols:80,row_off:0,col_off:0,
        dirty:false,filename:"",status:[0;128],status_ttl:0,
    };
    ed_init(&mut ed);
    ed_insert_char(&mut ed,'A' as u8);
    return ed.lines[0].len==1 && ed.lines[0].buf[0]=='A' as u8;
}

/* Test insertion ligne */
fn test_insert_row()->bool{
    let mut ed=Editor{
        nlines:0, lines:[Line{len:0,buf:[0;256]};2000],
        cx:0,cy:0,rows:24,cols:80,row_off:0,col_off:0,
        dirty:false,filename:"",status:[0;128],status_ttl:0,
    };
    ed_init(&mut ed);
    ed_insert_row(&mut ed,0,"Hello");
    return ed.nlines==1 && ed.lines[0].len==5;
}

/* Test suppression caractère */
fn test_del_char()->bool{
    let mut ed=Editor{
        nlines:0, lines:[Line{len:0,buf:[0;256]};2000],
        cx:0,cy:0,rows:24,cols:80,row_off:0,col_off:0,
        dirty:false,filename:"",status:[0;128],status_ttl:0,
    };
    ed_init(&mut ed);
    ed_insert_row(&mut ed,0,"AB");
    ed.cy=0; ed.cx=1;
    ed_del_char(&mut ed);
    return ed.lines[0].len==1 && ed.lines[0].buf[0]=='A' as u8;
}

/* Test status flag dirty */
fn test_dirty_flag()->bool{
    let mut ed=Editor{
        nlines:0, lines:[Line{len:0,buf:[0;256]};2000],
        cx:0,cy:0,rows:24,cols:80,row_off:0,col_off:0,
        dirty:false,filename:"",status:[0;128],status_ttl:0,
    };
    ed_init(&mut ed);
    ed_insert_row(&mut ed,0,"X");
    return ed.dirty;
}

/* Runner */
fn main()->i32{
    let ok1=test_insert_char();
    let ok2=test_insert_row();
    let ok3=test_del_char();
    let ok4=test_dirty_flag();
    if ok1 && ok2 && ok3 && ok4 {
        println("All editor_buffer tests passed.");
        return 0;
    } else {
        println("Some tests FAILED.");
        return 1;
    }
}