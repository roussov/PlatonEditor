# cpp.syntax — Coloration C++20/23
# Encodage: UTF-8

[meta]
name = C++
version = 1.0
file_extensions = .cpp,.hpp,.cc,.hh,.cxx,.hxx,.ixx,.tpp
case_sensitive = true

[colors]
comment = comment
string  = string
number  = number
keyword = keyword
type    = type
storage = storage
macro   = macro
preproc = preproc
func    = function
const   = constant
op      = operator
punct   = punctuation
invalid = invalid
todo    = todo

[states]
initial = code

[state:code]
# Commentaires
rule.doc.line  = (?P<comment>///[^\n]*) -> comment
rule.doc.inner = (?P<comment>//![^\n]*) -> comment
rule.cmt.line  = (?P<comment>//[^\n]*)  -> comment
rule.cmt.blk   = (?P<comment>/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)s -> comment
rule.todo      = (?P<todo>(?://|/\*)\s*(?:TODO|FIXME|BUG|HACK|NOTE)\b.*?(?:\*/)?$) -> todo

# Chaînes et caractères
push.str.dq    = " -> string_dq
push.str.sq    = ' -> string_sq     # char
push.str.raw   = R" -> raw_string_start

# Nombres
rule.num.hex   = (?P<number>\b0[xX][0-9A-Fa-f](?:_?[0-9A-Fa-f])*(?:[uUlLfF]+)?\b) -> number
rule.num.bin   = (?P<number>\b0[bB][01](?:_?[01])*(?:[uUlLfF]+)?\b) -> number
rule.num.oct   = (?P<number>\b0[0-7](?:_?[0-7])*(?:[uUlLfF]+)?\b) -> number
rule.num.float = (?P<number>\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?(?:[fFlL])?\b) -> number
rule.num.dec   = (?P<number>\b\d(?:_?\d)*(?:[uUlL]+)?\b) -> number

# Préprocesseur
rule.pp.dir    = (?P<preproc>^[ \t]*#[ \t]*[a-zA-Z_][a-zA-Z_0-9]*) -> preproc
rule.pp.inc    = (?P<preproc>^[ \t]*#[ \t]*include)\s+(?P<string><[^>\n]+>|"([^"\\]|\\.)*") -> preproc,string
rule.pp.def    = (?P<macro>^[ \t]*#[ \t]*define)\s+(?P<const>[A-Z_][A-Z0-9_]*) -> macro,constant
rule.pp.pragma = (?P<preproc>^[ \t]*#[ \t]*pragma\b.*)$ -> preproc
rule.pp.cont   = (?P<preproc>\\\n) -> preproc

# Mots-clés C++
rule.keyword = (?P<keyword>\b(?:alignas|alignof|asm|auto|break|case|catch|class|co_await|co_return|co_yield|concept|const|consteval|constexpr|constinit|const_cast|continue|decltype|default|delete|do|dynamic_cast|else|enum|explicit|export|extern|final|for|friend|goto|if|import|inline|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|reflexpr|register|reinterpret_cast|required|requires|return|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|using|virtual|volatile|while)\b) -> keyword

# Types intégrés et STL courants
rule.type = (?P<type>\b(?:bool|char|char8_t|char16_t|char32_t|wchar_t|short|int|long|float|double|signed|unsigned|void|string|size_t|ptrdiff_t|nullptr_t|std::string|std::u8string|std::u16string|std::u32string|std::wstring|std::vector|std::array|std::deque|std::list|std::map|std::unordered_map|std::set|std::unordered_set|std::tuple|std::pair|std::optional|std::variant|std::any|std::span|std::unique_ptr|std::shared_ptr|std::weak_ptr|std::function)\b) -> type

# Constantes
rule.const = (?P<const>\b(?:true|false|nullptr)\b) -> constant

# Identifiants de fonction
rule.func.call = (?P<func>\b[A-Za-z_][A-Za-z0-9_]*)(?=\s*\() -> function
rule.op.func   = (?P<func>\boperator\b) -> function

# Portée et templates
rule.scope = (?P<op>::) -> operator
rule.tmpl  = (?P<keyword>\btemplate\b)(?=\s*<) -> keyword
rule.req   = (?P<keyword>\brequires\b) -> keyword

# Classes, structs, enum
rule.agg   = (?P<keyword>\b(?:class|struct|union|enum)\b) -> keyword

# Modules (C++20)
rule.mod   = (?P<keyword>\b(?:module|import|export)\b) -> keyword

# Attributs [[...]]
rule.attr  = (?P<preproc>\[\[[^\]]*\]\]) -> preproc

# Opérateurs et ponctuation
rule.ops   = (?P<op>(\+\+|--|->|\.\*|->\*|::|=>|==|!=|<=|>=|&&|\|\||<<|>>|<<=|>>=|\+=|-=|\*=|/=|%=|&=|\|=|\^=|=|<|>|\?|\:|\.\.\.|[+\-*/%&|\^~!\.])) -> operator
rule.punct = (?P<punct>[{}\[\]();,]) -> punctuation

# Macros en MAJUSCULES
rule.macro.ident = (?P<const>\b[A-Z][A-Z0-9_]{2,}\b) -> constant

# Labels
rule.label = (?P<const>^[ \t]*[A-Za-z_][A-Za-z0-9_]*:)(?!:) -> constant

# Invalides fréquents
rule.invalid.char = (?P<invalid>'(?:\\.|[^\\']){0,0}') -> invalid

# ===================== CHAÎNES ======================

[state:string_dq]
rule.escape = (?P<string>\\(?:x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[\\'"nrt0])) -> string
rule.end    = " -> pop
rule.body   = (?P<string>[^"\\]+) -> string
rule.nl     = (?P<invalid>\n) -> invalid

[state:string_sq] # caractère
rule.escape = (?P<string>\\(?:x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[\\'"nrt0])) -> string
rule.end    = ' -> pop
rule.body   = (?P<string>[^'\\]) -> string
rule.nl     = (?P<invalid>\n) -> invalid

# ===================== RAW STRINGS ======================
# Capture de l’étiquette: R"tag( ... )tag"
[state:raw_string_start]
rule.tag = (?P<punct>\() -> punctuation,raw_string_body_start
rule.label = (?P<const>[A-Za-z0-9_]{0,16}) -> constant

[state:raw_string_body_start]
# consomme le '(' déjà lu, passe en corps
rule.noop =  -> raw_string_body

[state:raw_string_body]
# Utilise retour arrière pour fermer avec )<label>"
rule.end = \)(?P<const>[A-Za-z0-9_]{0,16})" -> pop
rule.body = (?P<string>[\s\S]+?(?=\)[A-Za-z0-9_]{0,16}"))s -> string