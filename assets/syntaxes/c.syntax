# c.syntax — Coloration C11
# Encodage: UTF-8

[meta]
name = C
version = 1.0
file_extensions = .c,.h
case_sensitive = true

[colors]
comment = comment
string  = string
number  = number
keyword = keyword
type    = type
storage = storage
macro   = macro
preproc = preproc
func    = function
const   = constant
op      = operator
punct   = punctuation
invalid = invalid
todo    = todo

[states]
initial = code

[state:code]
# Commentaires
rule.comment.line = (?P<comment>//[^\n]*) -> comment
rule.comment.blk  = (?P<comment>/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)s -> comment
rule.todo         = (?P<todo>(?://|/\*)\s*(?:TODO|FIXME|BUG|HACK|NOTE)\b.*) -> todo

# Chaînes et caractères
push.str.dq  = " -> string_dq
push.str.sq  = ' -> string_sq

# Nombres
rule.num.hex   = (?P<number>\b0[xX][0-9A-Fa-f](?:_?[0-9A-Fa-f])*(?:[uUlL]+)?\b) -> number
rule.num.bin   = (?P<number>\b0[bB][01](?:_?[01])*(?:[uUlL]+)?\b) -> number
rule.num.oct   = (?P<number>\b0[0-7](?:_?[0-7])*(?:[uUlL]+)?\b) -> number
rule.num.float = (?P<number>\b(?:\d(?:_?\d)*)?\.(?:\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?[fFlL]?\b|\b\d(?:_?\d)*[eE][+-]?\d(?:_?\d*)[fFlL]?\b) -> number
rule.num.dec   = (?P<number>\b\d(?:_?\d)*(?:[uUlL]+)?\b) -> number

# Préprocesseur
rule.pp.directive = (?P<preproc>^[ \t]*#[ \t]*[a-zA-Z_][a-zA-Z_0-9]*) -> preproc
rule.pp.include   = (?P<preproc>^[ \t]*#[ \t]*include)\s+(?P<string><[^>\n]+>|"([^"\\]|\\.)*") -> preproc,string
rule.pp.define    = (?P<macro>^[ \t]*#[ \t]*define)\s+(?P<const>[A-Z_][A-Z0-9_]*) -> macro,constant
rule.pp.pragma    = (?P<preproc>^[ \t]*#[ \t]*pragma\b.*)$ -> preproc
rule.pp.cont      = (?P<preproc>\\\n) -> preproc

# Mots-clés C11
rule.keyword = (?P<keyword>\b(?:if|else|switch|case|default|break|continue|for|while|do|goto|return|sizeof|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local)\b) -> keyword

# Types et qualificatifs
rule.type    = (?P<type>\b(?:void|char|short|int|long|float|double|signed|unsigned|bool|_Bool|wchar_t|char16_t|char32_t|size_t|ssize_t|ptrdiff_t|intptr_t|uintptr_t|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t)\b) -> type
rule.storage = (?P<storage>\b(?:const|volatile|restrict|static|extern|register|inline|typedef|auto)\b) -> storage

# Constantes usuelles
rule.const = (?P<const>\b(?:NULL|true|false)\b) -> constant

# Identifiants de fonction
rule.func.call = (?P<func>\b[A-Za-z_][A-Za-z0-9_]*)(?=\s*\() -> function

# Opérateurs et ponctuation
rule.ops   = (?P<op>(\+\+|--|->|\.|~|!|\*|/|%|\+|-|<<|>>|<=|>=|==|!=|<|>|&|\^|\||&&|\|\||\?|:|=|\+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=)) -> operator
rule.punct = (?P<punct>[{}\[\]();,]) -> punctuation

# Macros en MAJUSCULES
rule.macro.ident = (?P<const>\b[A-Z][A-Z0-9_]{2,}\b) -> constant

# Labels
rule.label = (?P<const>^[ \t]*[A-Za-z_][A-Za-z0-9_]*:)(?!:) -> constant

# Invalides fréquents
rule.invalid.char = (?P<invalid>'(?:\\.|[^\\']){0,0}') -> invalid

# ===================== CHAÎNES ======================

[state:string_dq]
rule.escape = (?P<string>\\(?:x[0-9A-Fa-f]{2}|[0-7]{1,3}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[\\'"nrt0])) -> string
rule.end    = " -> pop
rule.body   = (?P<string>[^"\\]+) -> string
rule.nl     = (?P<invalid>\n) -> invalid

[state:string_sq]  # caractères
rule.escape = (?P$string>\\(?:x[0-9A-Fa-f]{2}|[0-7]{1,3}|[\\'"nrt0])) -> string
rule.end    = ' -> pop
rule.body   = (?P<string>[^'\\]) -> string
rule.nl     = (?P<invalid>\n) -> invalid