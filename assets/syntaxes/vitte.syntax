# Vitte language syntax for Platon Editor
# Spec: https://github.com/vitte-lang/vitte  â€” version 0.1.0
# Encoding: UTF-8

[meta]
name = Vitte
version = 0.1.0
source_url = https://github.com/vitte-lang/vitte
file_extensions = .vitte,.vit
case_sensitive = true

[colors]
comment = comment
string  = string
char    = string
number  = number
keyword = keyword
control = keyword
bool    = constant
nil     = constant
type    = type
storage = storage
macro   = macro
preproc = preproc
func    = function
const   = constant
path    = type
op      = operator
punct   = punctuation
invalid = invalid
todo    = todo

[states]
initial = code

[state:code]
# ----------------------------- Comments ---------------------------------
rule.comment.line      = (?P<comment>//[^\n]*) -> comment
rule.comment.doc.line  = (?P<comment>///[^\n]*) -> comment
rule.comment.block     = (?P<comment>/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)s -> comment
rule.comment.doc.block = (?P<comment>/\*\*[^*]*\*+(?:[^/*][^*]*\*+)*/)s -> comment
rule.todo              = (?P<todo>//\s*(?:TODO|FIXME|BUG|HACK).*) -> todo

# ----------------------------- Attributes -------------------------------
# Rust-like attributes supported by Vitte examples
rule.attr.inner  = (?P<preproc>#!\[[^\]]*\]) -> preproc
rule.attr.outer  = (?P<preproc>#\[[^\]]*\]) -> preproc

# ----------------------------- Literals ---------------------------------
rule.string.dq = (?P<string>"(?:\\.|[^"\\])*") -> string
rule.char      = (?P<char>'(?:\\.|[^'\\])') -> char

# Numbers: hex, bin, oct, float, int with _ separators
rule.number.hex = (?P<number>0[xX][0-9A-Fa-f](?:_?[0-9A-Fa-f])*) -> number
rule.number.bin = (?P<number>0[bB][01](?:_?[01])*) -> number
rule.number.oct = (?P<number>0[oO][0-7](?:_?[0-7])*) -> number
rule.number.fp  = (?P<number>\b\d(?:_?\d)*\.(?:\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?\b) -> number
rule.number.int = (?P<number>\b\d(?:_?\d)*\b) -> number

rule.bool = (?P<bool>\b(?:true|false)\b) -> bool
rule.nil  = (?P<nil>(?:nil)) -> nil

# ----------------------------- Keywords ---------------------------------
# Storage/decl keywords
rule.storage = (?P<storage>(?:module|import|pub|fn|let|const|type|struct|enum|union|static|mut)) -> storage
# Control-flow and other reserved words
rule.keyword = (?P<keyword>(?:if|else|match|while|for|in|loop|break|continue|return|as|where)) -> keyword

# ----------------------------- Types ------------------------------------
rule.builtin.type = (?P<type>\b(?:i8|i16|i32|i64|i128|u8|u16|u32|u64|u128|isize|usize|f32|f64|bool|char|str|String|Vec|Option|Result)\b) -> type

# --------------------------- Idents & Paths ------------------------------
# Function names after `fn`
rule.fn.name = (?<=\bfn\s)(?P<func>[A-Za-z_][A-Za-z0-9_]*) -> func
# CONST_LIKE identifiers
rule.const.like = (?P<const>\b[A-Z][A-Z0-9_]{2,}\b) -> const
# Module or type paths like foo::bar::Baz
rule.path.ns = (?P<path>\b[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)+\b) -> path

# ----------------------------- Macros -----------------------------------
rule.macro.call = (?P<macro>\b[A-Za-z_][A-Za-z0-9_]*!) -> macro

# --------------------------- Operators/Punct -----------------------------
rule.operator = (?P<op>==|!=|<=|>=|<<|>>|\+|\-|\*|/|%|&&|\|\||!|=|::|->|=>|\?|:|~|\^|&|\|) -> op
rule.punct    = (?P<punct>[\[\]{}()\.,;]) -> punct

# ----------------------------- Invalid ----------------------------------
# Unclosed string or char
rule.invalid.unclosed = (?P<invalid>"[^"\n]*$|'[^'\n]*$) -> invalid

# ----------------------------- Extras -----------------------------------
# Lifetimes (Rust-like). Color as type for lack of a dedicated group.
rule.lifetime = (?P<type>\B'[_a-zA-Z][_a-zA-Z0-9]*\b) -> type

# End of vitte.syntax
