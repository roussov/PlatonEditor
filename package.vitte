/* ============================================================================
   package.vitte — Gestion ultra-complète de paquet / manifest pour Platon Editor
   But:
     - Lire un manifest (format INI étendu) depuis disk
     - Représenter package, deps (nom, version, path local), scripts, metadata
     - Résolution des dépendances locales + tri topologique du build
     - Hachage FNV-1a (lock) et génération d’un lock minimal en mémoire
     - Exécution de scripts simples (echo, cp, rm, mkdir -p) par backend
   Contraintes:
     - Zéro allocation dynamique; buffers statiques bornés
     - ASCII/UTF-8 simple; chemins <= 255, lignes manifest <= 1024
     - Backends runtime_* à mapper côté hôte (FS/exec/clock)
   ============================================================================ */

const PATH_MAX:     i32 = 256;
const FILE_MAX:     i32 = 1_000_000;
const LINES_MAX:    i32 = 4096;
const LINE_MAX:     i32 = 1024;
const SECT_MAX:     i32 = 64;
const KV_MAX:       i32 = 256;
const STR_SMALL:    i32 = 64;
const STR_MED:      i32 = 128;
const SCRIPTS_MAX:  i32 = 32;
const DEPS_MAX:     i32 = 256;
const NODES_MAX:    i32 = 512;
const EDGES_MAX:    i32 = 2048;

/* ============================== Types ===================================== */

struct KV {
    k: [u8; STR_SMALL],  klen: i32,
    v: [u8; STR_MED],    vlen: i32,
}

struct Section {
    name: [u8; STR_SMALL], nlen: i32,
    kv: [KV; KV_MAX],
    n: i32,
}

struct Manifest {
    /* sections par nom: package, dependencies, scripts, build, extras… */
    sects: [Section; SECT_MAX],
    nsects: i32,
}

struct Semver {
    major: i32, minor: i32, patch: i32,
    /* simple: pas de pré-release/build */
}

struct Dep {
    name:   [u8; STR_SMALL], nlen: i32,
    req:    [u8; STR_SMALL], rlen: i32, /* ex: ">=0.1.0", "^1.2", "*" */
    path:   [u8; PATH_MAX],  plen: i32, /* optionnel: chemin local relatif */
}

struct Script {
    name: [u8; STR_SMALL], nlen: i32,
    body: [u8; LINE_MAX],  blen: i32, /* simple: une ligne de shell-like */
}

struct PackageMeta {
    name:    [u8; STR_SMALL], nlen: i32,
    version: Semver,
    authors: [u8; STR_MED],   alen: i32,
    license: [u8; STR_SMALL], llen: i32,
    descr:   [u8; STR_MED],   dlen: i32,
}

struct Package {
    meta: PackageMeta,
    deps: [Dep; DEPS_MAX], ndeps: i32,
    scripts: [Script; SCRIPTS_MAX], nscripts: i32,
    root: [u8; PATH_MAX], rlen: i32, /* dir du manifest */
}

struct Node {
    name: [u8; STR_SMALL], nlen: i32,
    idx: i32, indeg: i32,
}

struct Edge { from: i32, to: i32 }

struct Graph {
    nodes: [Node; NODES_MAX], n: i32,
    edges: [Edge; EDGES_MAX], m: i32,
}

/* ============================== Utils ASCII =============================== */

fn min(a:i32,b:i32)->i32{ if a<b {return a;} return b; }
fn max(a:i32,b:i32)->i32{ if a>b {return a;} return b; }

fn cpy_str(dst:&mut [u8; STR_SMALL], s:str)->i32 {
    let L = min(strlen_ascii(s), STR_SMALL-1);
    let mut i=0; while i<L { dst[i as usize]=s[i as usize] as u8; i=i+1; }
    dst[L as usize]=0; return L;
}
fn cpy_buf(dst:&mut [u8; STR_MED], src:&[u8; STR_MED], n:i32){
    let L=min(n,STR_MED-1); let mut i=0; while i<L { dst[i as usize]=src[i as usize]; i=i+1; } dst[L as usize]=0;
}
fn cpy_bytes(dst:&mut [u8; PATH_MAX], src:&[u8; PATH_MAX], n:i32){
    let L=min(n,PATH_MAX-1); let mut i=0; while i<L { dst[i as usize]=src[i as usize]; i=i+1; } dst[L as usize]=0;
}
fn from_str_to_path(dst:&mut [u8; PATH_MAX], s:str)->i32 {
    let L=min(strlen_ascii(s), PATH_MAX-1); let mut i=0; while i<L { dst[i as usize]=s[i as usize] as u8; i=i+1; } dst[L as usize]=0; return L;
}
fn bytes_eq(a:&[u8; STR_SMALL], al:i32, b:&[u8; STR_SMALL], bl:i32)->bool{
    if al!=bl {return false;} let mut i=0; while i<al { if a[i as usize]!=b[i as usize]{return false;} i=i+1;} return true;
}
fn str_eq(a:str,b:str)->bool{
    let la=strlen_ascii(a); let lb=strlen_ascii(b); if la!=lb {return false;}
    let mut i=0; while i<la { if a[i as usize]!=b[i as usize] {return false;} i=i+1;} return true;
}
fn str_starts_with(a:str, p:str)->bool{
    let la=strlen_ascii(a); let lp=strlen_ascii(p); if lp>la {return false;}
    let mut i=0; while i<lp { if a[i as usize]!=p[i as usize]{return false;} i=i+1;} return true;
}

/* ============================== Lecture fichier =========================== */

fn fs_read_all(path: str, out: &mut [u8; FILE_MAX]) -> i32 { return runtime_read_file_all(path, out); }

/* ============================== Parsing INI étendu ======================== */
/* Format:
   [package]
   name=PlatonEditor
   version=0.1.0
   authors=Vincent
   license=MIT
   description=...

   [dependencies]
   syntax.vitte=^0.1
   file.vitte=*

   [scripts]
   build=echo build && cp src/*.vitte dist/
*/

fn manifest_parse(buf:&[u8; FILE_MAX], n:i32, out:&mut Manifest)->bool{
    out.nsects=0;
    let mut line:[u8; LINE_MAX]; let mut L=0; let mut i=0;
    let mut cur = -1;
    while i<n {
        /* lire jusqu’à LF */
        L=0;
        while i<n && buf[i as usize]!=10u8 && L<LINE_MAX-1 { line[L as usize]=buf[i as usize]; L=L+1; i=i+1; }
        /* skip LF */
        if i<n && buf[i as usize]==10u8 { i=i+1; }
        /* trim CR */
        if L>0 && line[(L-1) as usize]==13u8 { L=L-1; }
        /* trim spaces */
        let (a,b)=trim_spaces_line(&line, L);
        if b<=a { continue; }
        /* comment ';' or '#' at start */
        if line[a as usize]==';' as u8 || line[a as usize]=='#' as u8 { continue; }
        /* section */
        if line[a as usize]=='[' as u8 {
            let mut j=a+1; while j<b && line[j as usize]!=']' as u8 { j=j+1; }
            if j<b && line[j as usize]==']' as u8 {
                if out.nsects>=SECT_MAX { return false; }
                let sidx=out.nsects; out.nsects=out.nsects+1;
                out.sects[sidx as usize].n=0;
                let nlen=min(j-(a+1), STR_SMALL-1);
                let mut k=0; while k<nlen { out.sects[sidx as usize].name[k as usize]=line[(a+1+k) as usize]; k=k+1; }
                out.sects[sidx as usize].nlen=nlen;
                cur = sidx;
            }
            continue;
        }
        /* kv */
        if cur<0 { continue; }
        let eq = find_char(&line, a, b, '=' as u8);
        if eq<0 { continue; }
        if out.sects[cur as usize].n>=KV_MAX { return false; }
        let kv_idx = out.sects[cur as usize].n; out.sects[cur as usize].n = kv_idx+1;

        /* key */
        let (ka,kb)=trim_spaces_line(&line, a);
        let (va0,_)=trim_spaces_line(&line, eq+1);
        let (va,vb)=(va0,b);

        let klen=min(kb-ka, STR_SMALL-1);
        let vlen=min(vb-va, STR_MED-1);
        let mut p=0; while p<klen { out.sects[cur as usize].kv[kv_idx as usize].k[p as usize]=line[(ka+p) as usize]; p=p+1; }
        out.sects[cur as usize].kv[kv_idx as usize].klen=klen;

        p=0; while p<vlen { out.sects[cur as usize].kv[kv_idx as usize].v[p as usize]=line[(va+p) as usize]; p=p+1; }
        out.sects[cur as usize].kv[kv_idx as usize].vlen=vlen;
    }
    return true;
}

fn trim_spaces_line(line:&[u8; LINE_MAX], L:i32)->(i32,i32){
    let mut a=0; let mut b=L;
    while a<b && (line[a as usize]==b' '||line[a as usize]==b'\t') { a=a+1; }
    while b>a && (line[(b-1) as usize]==b' '||line[(b-1) as usize]==b'\t') { b=b-1; }
    return (a,b);
}
fn find_char(line:&[u8; LINE_MAX], a:i32, b:i32, ch:u8)->i32{
    let mut i=a; while i<b { if line[i as usize]==ch { return i; } i=i+1; } return -1;
}

/* ============================== Semver simple ============================= */

fn parse_semver(s:str)->Semver{
    let mut v=Semver{major:0,minor:0,patch:0};
    let L=strlen_ascii(s); if L<=0 { return v; }
    let mut part=0; let mut acc=0; let mut i=0;
    while i<=L {
        let c = if i<L { s[i as usize] as u8 } else { '.' as u8 };
        if c=='.' as u8 {
            if part==0 { v.major=acc; }
            else if part==1 { v.minor=acc; }
            else { v.patch=acc; }
            part=part+1; acc=0;
        } else if c>='0' as u8 && c<='9' as u8 {
            acc = acc*10 + ((c-'0' as u8) as i32);
        } else {
            /* stop on non-digit */
            break;
        }
        i=i+1;
    }
    return v;
}

fn cmp_semver(a:&Semver,b:&Semver)->i32{
    if a.major!=b.major { return if a.major<b.major {-1} else {1}; }
    if a.minor!=b.minor { return if a.minor<b.minor {-1} else {1}; }
    if a.patch!=b.patch { return if a.patch<b.patch {-1} else {1}; }
    return 0;
}

/* match d’une contrainte très simple: "*", "^X.Y", ">=", "==" */
fn semver_satisfies(v:&Semver, req:str)->bool{
    if req=="" || str_eq(req,"*") { return true; }
    if str_starts_with(req,"^") {
        let base = parse_semver(slice_after(req,1));
        if v.major!=base.major { return false; }
        if v.minor<base.minor { return false; }
        if v.minor==base.minor && v.patch<base.patch { return false; }
        return true;
    }
    if str_starts_with(req,">=") {
        let base = parse_semver(slice_after(req,2));
        return cmp_semver(v,&base)>=0;
    }
    if str_starts_with(req,"==") || str_starts_with(req,"=") {
        let base = parse_semver(slice_after(req, if str_starts_with(req,"=="){2}else{1}));
        return cmp_semver(v,&base)==0;
    }
    /* fallback: égalité stricte X.Y.Z */
    let base = parse_semver(req);
    return cmp_semver(v,&base)==0;
}

fn slice_after(s:str, start:i32)->str {
    /* runtime peut renvoyer un sous-texte; sinon dépend de la std. Stub: retourne s. */
    return s; /* à mapper côté hôte si nécessaire */
}

/* ============================== Extraction Manifest -> Package ============ */

fn sect_get(m:&Manifest, name:str)->i32{
    let mut i=0; while i<m.nsects {
        if sect_name_eq(&m.sects[i as usize], name) { return i; }
        i=i+1;
    }
    return -1;
}
fn sect_name_eq(s:&Section, name:str)->bool{
    let L = min(strlen_ascii(name), STR_SMALL-1);
    if L!=s.nlen { return false; }
    let mut i=0; while i<L { if s.name[i as usize] != name[i as usize] as u8 { return false; } i=i+1; }
    return true;
}
fn kv_find(s:&Section, key:str)->i32{
    let K=min(strlen_ascii(key), STR_SMALL-1);
    let mut i=0; while i<s.n {
        if s.kv[i as usize].klen==K {
            let mut ok=true; let mut j=0;
            while j<K { if s.kv[i as usize].k[j as usize]!=key[j as usize] as u8 { ok=false; break; } j=j+1; }
            if ok { return i; }
        }
        i=i+1;
    }
    return -1;
}

/* Remplit pkg.meta, pkg.deps, pkg.scripts. root_path = dir du manifest. */
fn package_from_manifest(m:&Manifest, root_path:str, out:&mut Package)->bool{
    out.ndeps=0; out.nscripts=0; out.rlen = from_str_to_path(&mut out.root, root_path);

    /* [package] */
    let sp = sect_get(m,"package");
    if sp>=0 {
        let s = &m.sects[sp as usize];
        /* name */
        let ki = kv_find(s,"name");
        if ki<0 { return false; }
        out.meta.nlen = min(s.kv[ki as usize].vlen, STR_SMALL-1);
        let mut i=0; while i<out.meta.nlen { out.meta.name[i as usize]=s.kv[ki as usize].v[i as usize]; i=i+1; }
        out.meta.name[out.meta.nlen as usize]=0;

        /* version */
        let kvv = kv_find(s,"version");
        if kvv<0 { out.meta.version = Semver{major:0,minor:1,patch:0}; }
        else {
            let tmp = buf_to_tmpstr(&s.kv[kvv as usize].v, s.kv[kvv as usize].vlen);
            out.meta.version = parse_semver(tmp);
        }
        /* authors, license, description (optionnels) */
        let ka = kv_find(s,"authors"); if ka>=0 { out.meta.alen = copy_med(&mut out.meta.authors, &s.kv[ka as usize].v, s.kv[ka as usize].vlen); }
        let kl = kv_find(s,"license"); if kl>=0 { out.meta.llen = copy_small(&mut out.meta.license, &s.kv[kl as usize].v, s.kv[kl as usize].vlen); }
        let kd = kv_find(s,"description"); if kd>=0 { out.meta.dlen = copy_med(&mut out.meta.descr, &s.kv[kd as usize].v, s.kv[kd as usize].vlen); }
    } else { return false; }

    /* [dependencies] */
    let sd = sect_get(m,"dependencies");
    if sd>=0 {
        let s = &m.sects[sd as usize];
        let mut i=0; while i<s.n && out.ndeps<DEPS_MAX {
            let di = out.ndeps; out.ndeps = di+1;
            /* key = nom du dep, value = contrainte ou "path:xxx;ver:.." */
            let klen = min(s.kv[i as usize].klen, STR_SMALL-1);
            let mut k=0; while k<klen { out.deps[di as usize].name[k as usize]=s.kv[i as usize].k[k as usize]; k=k+1; }
            out.deps[di as usize].nlen=klen; out.deps[di as usize].name[klen as usize]=0;

            /* value parse */
            if contains_byte(&s.kv[i as usize].v, s.kv[i as usize].vlen, ':' as u8) {
                /* mini DSL: "path:./libs/foo;req:^1.2.0" */
                parse_dep_dsl(&s.kv[i as usize].v, s.kv[i as usize].vlen, &mut out.deps[di as usize]);
            } else {
                out.deps[di as usize].rlen = min(s.kv[i as usize].vlen, STR_SMALL-1);
                let mut j=0; while j<out.deps[di as usize].rlen { out.deps[di as usize].req[j as usize]=s.kv[i as usize].v[j as usize]; j=j+1; }
                out.deps[di as usize].req[out.deps[di as usize].rlen as usize]=0;
                out.deps[di as usize].plen=0; out.deps[di as usize].path[0]=0;
            }
            i=i+1;
        }
    }

    /* [scripts] */
    let ss = sect_get(m,"scripts");
    if ss>=0 {
        let s = &m.sects[ss as usize];
        let mut i=0; while i<s.n && out.nscripts<SCRIPTS_MAX {
            let si = out.nscripts; out.nscripts=si+1;
            /* name */
            let nlen=min(s.kv[i as usize].klen, STR_SMALL-1);
            let mut k=0; while k<nlen { out.scripts[si as usize].name[k as usize]=s.kv[i as usize].k[k as usize]; k=k+1; }
            out.scripts[si as usize].nlen=nlen; out.scripts[si as usize].name[nlen as usize]=0;
            /* body */
            let bl=min(s.kv[i as usize].vlen, LINE_MAX-1);
            let mut j=0; while j<bl { out.scripts[si as usize].body[j as usize]=s.kv[i as usize].v[j as usize]; j=j+1; }
            out.scripts[si as usize].blen=bl; out.scripts[si as usize].body[bl as usize]=0;
            i=i+1;
        }
    }

    return true;
}

fn buf_to_tmpstr(v:&[u8; STR_MED], n:i32)->str{ return bytes_to_str_med(v,n); }
fn copy_med(dst:&mut [u8; STR_MED], src:&[u8; STR_MED], n:i32)->i32{ let L=min(n,STR_MED-1); let mut i=0; while i<L { dst[i as usize]=src[i as usize]; i=i+1;} dst[L as usize]=0; return L; }
fn copy_small(dst:&mut [u8; STR_SMALL], src:&[u8; STR_MED], n:i32)->i32{ let L=min(n,STR_SMALL-1); let mut i=0; while i<L { dst[i as usize]=src[i as usize]; i=i+1;} dst[L as usize]=0; return L; }
fn contains_byte(v:&[u8; STR_MED], n:i32, ch:u8)->bool{ let mut i=0; while i<n { if v[i as usize]==ch {return true;} i=i+1;} return false; }

fn parse_dep_dsl(v:&[u8; STR_MED], n:i32, out:&mut Dep){
    /* "path:./lib;req:^1.2.0" ; champs optionnels */
    out.rlen=0; out.plen=0;
    let mut i=0;
    while i<n {
        /* lire key */
        let ks=i; while i<n && v[i as usize]!=':' as u8 { i=i+1; }
        if i>=n { break; } let ke=i; i=i+1; /* skip ':' */
        /* lire val jusqu'à ';' ou fin */
        let vs=i; while i<n && v[i as usize]!=';' as u8 { i=i+1; }
        let ve=i; if i<n { i=i+1; }
        /* key match */
        if match_bytes_str(&v, ks, ke, "path") {
            out.plen = min(ve-vs, PATH_MAX-1); let mut k=0; while k<out.plen { out.path[k as usize]=v[(vs+k) as usize]; k=k+1; } out.path[out.plen as usize]=0;
        } else if match_bytes_str(&v, ks, ke, "req") || match_bytes_str(&v, ks, ke, "ver") {
            out.rlen = min(ve-vs, STR_SMALL-1); let mut k=0; while k<out.rlen { out.req[k as usize]=v[(vs+k) as usize]; k=k+1; } out.req[out.rlen as usize]=0;
        }
    }
}
fn match_bytes_str(v:&[u8; STR_MED], a:i32, b:i32, s:str)->bool{
    let L=b-a; let ls=strlen_ascii(s); if L!=ls { return false; }
    let mut i=0; while i<L { if v[(a+i) as usize]!=s[i as usize] as u8 { return false; } i=i+1; }
    return true;
}

/* ============================== Graph & résolution ======================== */

fn graph_init(g:&mut Graph){ g.n=0; g.m=0; }
fn graph_add_node(g:&mut Graph, name:&[u8; STR_SMALL], nlen:i32)->i32{
    let mut i=0; while i<g.n {
        if bytes_eq(&g.nodes[i as usize].name, g.nodes[i as usize].nlen, name, nlen) { return g.nodes[i as usize].idx; }
        i=i+1;
    }
    if g.n>=NODES_MAX { return -1; }
    let idx=g.n; g.n=g.n+1;
    g.nodes[idx as usize].nlen=nlen;
    let mut k=0; while k<nlen { g.nodes[idx as usize].name[k as usize]=name[k as usize]; k=k+1; }
    g.nodes[idx as usize].name[nlen as usize]=0; g.nodes[idx as usize].idx=idx; g.nodes[idx as usize].indeg=0;
    return idx;
}
fn graph_add_edge(g:&mut Graph, u:i32, v:i32)->bool{
    if g.m>=EDGES_MAX { return false; }
    g.edges[g.m as usize] = Edge{from:u,to:v}; g.m=g.m+1;
    g.nodes[v as usize].indeg = g.nodes[v as usize].indeg + 1;
    return true;
}

/* Construit un graphe: chaque dep est un noeud, le package racine aussi.
   Arcs: root -> dep, et si un dep déclare d'autres deps (non résolu ici), stub. */
fn package_build_graph(pkg:&Package, g:&mut Graph)->bool{
    graph_init(g);
    let root_idx = graph_add_node(g, &pkg.meta.name, pkg.meta.nlen);
    if root_idx<0 { return false; }
    let mut i=0; while i<pkg.ndeps {
        let nlen=pkg.deps[i as usize].nlen;
        let mut nm:[u8; STR_SMALL]; let mut k=0; while k<nlen { nm[k as usize]=pkg.deps[i as usize].name[k as usize]; k=k+1; } nm[nlen as usize]=0;
        let di = graph_add_node(g, &nm, nlen);
        if di<0 { return false; }
        if !graph_add_edge(g, root_idx, di) { return false; }
        i=i+1;
    }
    return true;
}

/* Tri topo (Kahn). Retour: ordre dans out[0..cap-1], n retourné, -1 si cycle. */
fn topo_sort(g:&Graph, out:&mut [i32; NODES_MAX], cap:i32)->i32{
    let mut indeg:[i32; NODES_MAX];
    let mut i=0; while i<g.n { indeg[i as usize]=g.nodes[i as usize].indeg; i=i+1; }
    /* queue simple en tableau */
    let mut q:[i32; NODES_MAX]; let mut head=0; let mut tail=0;
    i=0; while i<g.n { if indeg[i as usize]==0 { q[tail as usize]=i; tail=tail+1; } i=i+1; }
    let mut k=0;
    while head<tail {
        let u=q[head as usize]; head=head+1;
        if k<cap { out[k as usize]=u; } k=k+1;
        /* parcourir edges */
        let mut e=0; while e<g.m {
            if g.edges[e as usize].from==u {
                let v=g.edges[e as usize].to;
                indeg[v as usize]=indeg[v as usize]-1;
                if indeg[v as usize]==0 { q[tail as usize]=v; tail=tail+1; }
            }
            e=e+1;
        }
    }
    if k!=g.n { return -1; } /* cycle */
    return k;
}

/* ============================== Hachage FNV-1a 64 ========================= */

fn fnv1a64(buf:&[u8; FILE_MAX], n:i32)->u64{
    let mut h:u64 = 0xcbf29ce484222325u64;
    let mut i=0;
    while i<n {
        h = h ^ (buf[i as usize] as u64);
        h = h * 0x100000001b3u64;
        i=i+1;
    }
    return h;
}

/* Génère contenu lock minimal:
   name=<name>
   version=<semver>
   deps=<count>
   hash=<fnv64hex>
*/
fn package_lock_generate(pkg:&Package, manifest_raw:&[u8; FILE_MAX], n:i32,
                         out:&mut [u8; FILE_MAX])->i32{
    let hash = fnv1a64(manifest_raw, n);
    let mut k=0;
    k += put_ascii(out,k,"name=");
    k += put_bytes(out,k,&pkg.meta.name, pkg.meta.nlen);
    k += put_ascii(out,k,"\nversion=");
    k += put_semver(out,k,&pkg.meta.version);
    k += put_ascii(out,k,"\ndeps=");
    k += put_i32(out,k,pkg.ndeps);
    k += put_ascii(out,k,"\nhash=");
    k += put_hex64(out,k,hash);
    k += put_ascii(out,k,"\n");
    return k;
}

fn put_ascii(dst:&mut [u8; FILE_MAX], off:i32, s:str)->i32{
    let L=min(strlen_ascii(s), FILE_MAX-1-off); let mut i=0; while i<L { dst[(off+i) as usize]=s[i as usize] as u8; i=i+1; } return L;
}
fn put_bytes(dst:&mut [u8; FILE_MAX], off:i32, s:&[u8; STR_SMALL], n:i32)->i32{
    let L=min(n, FILE_MAX-1-off); let mut i=0; while i<L { dst[(off+i) as usize]=s[i as usize]; i=i+1; } return L;
}
fn put_i32(dst:&mut [u8; FILE_MAX], off:i32, v:i32)->i32{ let mut buf:[u8;32]; let n=i32_to_ascii(v,&mut buf); let mut i=0; while i<n { dst[(off+i) as usize]=buf[i as usize]; i=i+1;} return n; }
fn put_semver(dst:&mut [u8; FILE_MAX], off:i32, v:&Semver)->i32{
    let mut k=0; k+=put_i32(dst,off+k,v.major); k+=put_ascii(dst,off+k,".");
    k+=put_i32(dst,off+k,v.minor); k+=put_ascii(dst,off+k,".");
    k+=put_i32(dst,off+k,v.patch); return k;
}
fn put_hex64(dst:&mut [u8; FILE_MAX], off:i32, x:u64)->i32{
    let mut buf:[u8;16]; let mut i=15; let hex="0123456789abcdef";
    let mut v=x; while i>=0 { let d=(v & 0xFu64) as i32; buf[i as usize]=hex[d as usize] as u8; v = v>>4; i=i-1; }
    let mut k=0; while k<16 { dst[(off+k) as usize]=buf[k as usize]; k=k+1; } return 16;
}
fn i32_to_ascii(mut v:i32, out:&mut [u8;32])->i32{ if v==0 { out[0]=48; return 1; } let mut neg=false; if v<0 {neg=true; v=-v;} let mut tmp:[u8;16]; let mut t=0; while v>0 { tmp[t as usize]=48+((v%10) as u8); t=t+1; v=v/10; } let mut k=0; if neg { out[k as usize]=45; k=k+1; } let mut i=t-1; while i>=0 { out[k as usize]=tmp[i as usize]; k=k+1; i=i-1; } return k; }

/* ============================== Exécution de scripts ====================== */
/* Interpréteur minimal: commandes séparées par '&&' non supportées ici;
   on accepte une ligne unique:
     echo TEXT...
     mkdir -p PATH
     rm PATH
     cp SRC DST
   Retour bool succès/échec. */
fn scripts_run_one(pkg:&Package, name:str)->bool{
    let idx = script_find(pkg, name); if idx<0 { return false; }
    let s = &pkg.scripts[idx as usize];
    return eval_command_line(&s.body, s.blen, &pkg.root, pkg.rlen);
}
fn script_find(pkg:&Package, name:str)->i32{
    let L=min(strlen_ascii(name), STR_SMALL-1);
    let mut i=0; while i<pkg.nscripts {
        if pkg.scripts[i as usize].nlen==L {
            let mut ok=true; let mut k=0; while k<L { if pkg.scripts[i as usize].name[k as usize]!=name[k as usize] as u8 { ok=false; break; } k=k+1; }
            if ok { return i; }
        }
        i=i+1;
    }
    return -1;
}

fn eval_command_line(buf:&[u8; LINE_MAX], n:i32, cwd:&[u8; PATH_MAX], _cwdlen:i32)->bool{
    let (a,b)=skip_ws(buf,0,n);
    if a>=b { return true; }
    /* parse mot 1 */
    let (w1a,w1b)=read_word(buf,a,b);
    if w1a<0 { return false; }
    if eq_word(buf,w1a,w1b,"echo") {
        runtime_log_bytes(&buf[w1b as usize], b-w1b); return true;
    }
    if eq_word(buf,w1a,w1b,"mkdir") {
        let (wa,wb)=read_word(buf,w1b,b);
        if wa<0 { return false; }
        /* option -p ignorée si présent */
        let mut nexta=wa; if eq_word(buf,wa,wb,"-p") { let nx=read_word(buf,wb,b); nexta=nx.0; if nexta<0 {return false;} }
        let (pa,pb)=read_word(buf,nexta,b); if pa<0 { return false; }
        let mut path:[u8; PATH_MAX]; let plen=copy_slice(&mut path,&buf,pa,pb,PATH_MAX);
        return runtime_mkdir_p(&path, plen)==0;
    }
    if eq_word(buf,w1a,w1b,"rm") {
        let (pa,pb)=read_word(buf,w1b,b); if pa<0 { return false; }
        let mut path:[u8; PATH_MAX]; let plen=copy_slice(&mut path,&buf,pa,pb,PATH_MAX);
        return runtime_rm(&path, plen)==0;
    }
    if eq_word(buf,w1a,w1b,"cp") {
        let (sa,sb)=read_word(buf,w1b,b); if sa<0 { return false; }
        let (da,db)=read_word(buf,sb,b); if da<0 { return false; }
        let mut src:[u8; PATH_MAX]; let sl=copy_slice(&mut src,&buf,sa,sb,PATH_MAX);
        let mut dst:[u8; PATH_MAX]; let dl=copy_slice(&mut dst,&buf,da,db,PATH_MAX);
        return runtime_cp(&src,sl,&dst,dl)==0;
    }
    /* fallback: non supporté */
    return false;
}

fn skip_ws(buf:&[u8; LINE_MAX], a:i32, b:i32)->(i32,i32){ let mut i=a; while i<b && (buf[i as usize]==b' '||buf[i as usize]==b'\t'){ i=i+1;} let mut j=b; while j>i && (buf[(j-1) as usize]==b' '||buf[(j-1) as usize]==b'\t'){ j=j-1;} return (i,j); }
fn read_word(buf:&[u8; LINE_MAX], a:i32, b:i32)->(i32,i32){ let mut i=a; while i<b && buf[i as usize]==b' ' { i=i+1;} if i>=b {return (-1,-1);} let s=i; while i<b && buf[i as usize]!=b' ' { i=i+1;} return (s,i); }
fn eq_word(buf:&[u8; LINE_MAX], a:i32, b:i32, w:str)->bool{
    let L=b-a; let lw=strlen_ascii(w); if L!=lw {return false;} let mut i=0; while i<L { if buf[(a+i) as usize]!=w[i as usize] as u8 {return false;} i=i+1;} return true;
}
fn copy_slice(dst:&mut [u8; PATH_MAX], src:&[u8; LINE_MAX], a:i32, b:i32, cap:i32)->i32{
    let L=min(b-a, cap-1); let mut i=0; while i<L { dst[i as usize]=src[(a+i) as usize]; i=i+1;} dst[L as usize]=0; return L;
}

/* ============================== API de haut niveau ======================== */

fn package_load(manifest_path: str, root_dir: str, out:&mut Package)->bool{
    let mut buf:[u8; FILE_MAX]; let n=fs_read_all(manifest_path, &mut buf);
    if n<=0 { return false; }
    let mut man = Manifest{ sects:[Section{ name:[0;STR_SMALL], nlen:0, kv:[KV{k:[0;STR_SMALL],klen:0,v:[0;STR_MED],vlen:0}; KV_MAX], n:0}; SECT_MAX], nsects:0 };
    if !manifest_parse(&buf, n, &mut man) { return false; }
    if !package_from_manifest(&man, root_dir, out) { return false; }
    return true;
}

/* Résout les deps localement:
   - Si dep.path non vide: vérifie existence (mockable)
   - Version: pour locaux on assume match; sinon req="*" toléré
   Retourne true si tous les deps sont satisfaits localement. */
fn package_resolve_local(pkg:&Package)->bool{
    let mut i=0; while i<pkg.ndeps {
        if pkg.deps[i as usize].plen>0 {
            if runtime_path_exists(&pkg.deps[i as usize].path, pkg.deps[i as usize].plen)==0 { return false; }
        } else {
            /* pas de registry: accepter "*" sinon warning */
            /* Ici on tolère req vide ou "*". */
            let req = tmpstr_small(&pkg.deps[i as usize].req, pkg.deps[i as usize].rlen);
            if !(req=="" || str_eq(req,"*")) {
                /* non résolu offline */
                return false;
            }
        }
        i=i+1;
    }
    return true;
}

fn package_build_order(pkg:&Package, out:&mut [i32; NODES_MAX])->i32{
    let mut g=Graph{ nodes:[Node{name:[0;STR_SMALL],nlen:0,idx:0,indeg:0}; NODES_MAX], n:0, edges:[Edge{from:0,to:0}; EDGES_MAX], m:0 };
    if !package_build_graph(pkg, &mut g) { return -1; }
    return topo_sort(&g, out, NODES_MAX);
}

/* Exécute un script par nom, true si OK */
fn package_run(pkg:&Package, script_name:str)->bool{
    return scripts_run_one(pkg, script_name);
}

/* ============================== Stubs runtime ============================= */
/* À mapper vers votre environnement.                                        */

fn runtime_read_file_all(_path:str, _out:&mut [u8; FILE_MAX])->i32 { return -1; }
fn bytes_to_str_med(_buf:&[u8; STR_MED], _n:i32)->str { return ""; }
fn strlen_ascii(_s:str)->i32 { return 0; }

fn runtime_mkdir_p(_path:&[u8; PATH_MAX], _n:i32)->i32 { return 0; }
fn runtime_rm(_path:&[u8; PATH_MAX], _n:i32)->i32 { return 0; }
fn runtime_cp(_src:&[u8; PATH_MAX], _sn:i32, _dst:&[u8; PATH_MAX], _dn:i32)->i32 { return 0; }
fn runtime_log_bytes(_buf:&[u8; LINE_MAX], _n:i32) {}

fn runtime_path_exists(_path:&[u8; PATH_MAX], _n:i32)->i32 { return 1; } /* 1 existe, 0 non */

/* ============================== Exemple (commenté) ========================
fn println(_s:str){}
fn println_i32(_x:i32){}
fn main()->i32{
    let mut pkg = Package{
        meta:PackageMeta{
            name:[0;STR_SMALL], nlen:0, version:Semver{major:0,minor:1,patch:0},
            authors:[0;STR_MED], alen:0, license:[0;STR_SMALL], llen:0, descr:[0;STR_MED], dlen:0,
        },
        deps:[Dep{ name:[0;STR_SMALL], nlen:0, req:[0;STR_SMALL], rlen:0, path:[0;PATH_MAX], plen:0}; DEPS_MAX], ndeps:0,
        scripts:[Script{ name:[0;STR_SMALL], nlen:0, body:[0;LINE_MAX], blen:0}; SCRIPTS_MAX], nscripts:0,
        root:[0;PATH_MAX], rlen:0,
    };
    if !package_load("package.ini","./",&mut pkg) { println("load failed"); return 1; }
    if !package_resolve_local(&pkg) { println("resolve failed"); return 1; }
    let mut order:[i32; NODES_MAX]; let n=package_build_order(&pkg,&mut order);
    if n<0 { println("cycle"); return 1; }
    let mut lock:[u8; FILE_MAX];
    let mut raw:[u8; FILE_MAX]; let rn = runtime_read_file_all("package.ini",&mut raw);
    let ln = package_lock_generate(&pkg,&raw,rn,&mut lock);
    let _ = runtime_log_bytes_line(&lock, ln);
    let _ = package_run(&pkg,"build");
    return 0;
}
fn runtime_log_bytes_line(_b:&[u8; FILE_MAX], _n:i32){}
============================================================================ */