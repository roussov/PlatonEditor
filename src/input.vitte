/* ============================================================================
   input.vitte — Entrée terminal complète pour Vitte / Platon Editor
   - Mode raw on/off, écho on/off, flush, taille
   - Lecture d’une touche simple (compat editor.vitte) ET d’un évènement riche
   - Décodage séquences ESC/CSI/O : flèches, Home/End, PgUp/PgDn, Ins/Del
   - F1..F12, Ctrl-A..Z, Alt+char (ESC prefix), Alt+flèches (si reportés)
   - Souris SGR (1006): down/up/move/wheel + coords 1-based
   - Bracketed paste (2004): début/fin, agrégation en bloc
   - Sans alloc dyn. Petits buffers statiques. Hooks runtime_* requis.
   ============================================================================ */

/* -------------------- Codes de base (compat editor.vitte) ----------------- */

/* ASCII */
const KEY_ESC: i32 = 27;
const KEY_TAB: i32 = 9;
const KEY_LF:  i32 = 10;
const KEY_CR:  i32 = 13;
const KEY_BS:  i32 = 8;
const KEY_DEL: i32 = 127;

/* Navigation */
const K_UP:    i32 = 1001;
const K_DOWN:  i32 = 1002;
const K_LEFT:  i32 = 1003;
const K_RIGHT: i32 = 1004;
const K_HOME:  i32 = 1005;
const K_END:   i32 = 1006;
const K_PGUP:  i32 = 1007;
const K_PGDN:  i32 = 1008;
const K_INS:   i32 = 1009;

/* F-keys */
const K_F1:  i32 = 1101; const K_F2:  i32 = 1102; const K_F3:  i32 = 1103; const K_F4:  i32 = 1104;
const K_F5:  i32 = 1105; const K_F6:  i32 = 1106; const K_F7:  i32 = 1107; const K_F8:  i32 = 1108;
const K_F9:  i32 = 1109; const K_F10: i32 = 1110; const K_F11: i32 = 1111; const K_F12: i32 = 1112;

/* Modificateurs (bitmask) */
const M_SHIFT: i32 = 1;
const M_ALT:   i32 = 2;
const M_CTRL:  i32 = 4;

/* Evènements étendus */
const EV_KEY:   i32 = 1;
const EV_MOUSE: i32 = 2;
const EV_PASTE: i32 = 3;

/* Souris */
const MOUSE_DOWN:  i32 = 1201;
const MOUSE_UP:    i32 = 1202;
const MOUSE_MOVE:  i32 = 1203;
const MOUSE_WHEEL: i32 = 1204;

/* Bracketed paste */
const PASTE_BEGIN: i32 = 1301;
const PASTE_END:   i32 = 1302;

/* -------------------- Structures publiques -------------------------------- */

struct KeyEvent {
    kind: i32;   /* EV_KEY, EV_MOUSE, EV_PASTE */
    code: i32;   /* pour EV_KEY: K_* ou ASCII, pour EV_MOUSE: MOUSE_* */
    ch:   u32;   /* rune UTF-8 décodée si EV_KEY ASCII/printable, sinon 0 */
    mods: i32;   /* M_SHIFT|M_ALT|M_CTRL si détectés */
    x: i32;      /* souris: col 1-based ; sinon 0 */
    y: i32;      /* souris: row 1-based ; sinon 0 */
    delta: i32;  /* wheel +/-1.. ; sinon 0 */
}

/* -------------------- Etat local ----------------------------------------- */

struct TermState {
    raw: bool,
    echo: bool,
    alt_esc: bool,     /* Alt envoie ESC prefix */
    mouse_on: bool,    /* reporting actif */
    paste_on: bool,    /* bracketed paste actif */
    push_n: i32,
    push: [u8; 16],
}

let mut TS: TermState = TermState{
    raw:false, echo:false, alt_esc:true, mouse_on:false, paste_on:false,
    push_n:0, push:[0;16],
};

/* -------------------- API minimale compatible editor.vitte ---------------- */

fn term_enable_raw() { if !TS.raw { runtime_term_enable_raw(); TS.raw=true; } }
fn term_disable_raw() { if TS.raw { runtime_term_disable_raw(); TS.raw=false; } }

fn term_set_echo(on: bool) { TS.echo = on; runtime_term_set_echo(if on {1} else {0}); }

fn term_size() -> (i32, i32) {
    let mut r=24; let mut c=80; runtime_term_size(&mut r, &mut c); return (r, c);
}

fn term_flush_input() { TS.push_n=0; runtime_term_flush(); }

/* Simple: renvoie i32 comme avant */
fn term_read_key() -> i32 {
    let ev = term_read_event(-1);
    if ev.kind == EV_KEY { return ev.code; }
    return 0;
}

/* Peek non bloquant: timeout_ms = 0 non-bloquant, -1 bloquant sinon délai */
fn term_peek_key(timeout_ms: i32) -> i32 {
    let ev = term_read_event(timeout_ms);
    if ev.kind == EV_KEY { return ev.code; }
    return 0;
}

/* -------------------- API riche recommandée ------------------------------- */

fn term_read_event(timeout_ms: i32) -> KeyEvent {
    /* 1. lire premier octet */
    let mut b0:u8=0;
    if !read_byte(&mut b0, timeout_ms) {
        return KeyEvent{kind:0,code:0,ch:0,mods:0,x:0,y:0,delta:0};
    }

    /* ASCII imprimable et CR/LF/TAB/BS/DEL */
    if b0 >= 32 && b0 <= 126 {
        return KeyEvent{kind:EV_KEY, code:b0 as i32, ch:b0 as u32, mods:0,x:0,y:0,delta:0};
    }
    if b0 == KEY_TAB as u8 { return KeyEvent{kind:EV_KEY,code:KEY_TAB,ch:9,mods:0,x:0,y:0,delta:0}; }
    if b0 == KEY_CR  as u8 { return KeyEvent{kind:EV_KEY,code:KEY_CR, ch:13,mods:0,x:0,y:0,delta:0}; }
    if b0 == KEY_LF  as u8 { return KeyEvent{kind:EV_KEY,code:KEY_LF, ch:10,mods:0,x:0,y:0,delta:0}; }
    if b0 == KEY_BS  as u8 { return KeyEvent{kind:EV_KEY,code:KEY_BS, ch:0, mods:0,x:0,y:0,delta:0}; }
    if b0 == KEY_DEL as u8 { return KeyEvent{kind:EV_KEY,code:KEY_DEL,ch:0, mods:0,x:0,y:0,delta:0}; }

    /* Ctrl-A..Z (1..26) */
    if b0 >= 1 && b0 <= 26 {
        return KeyEvent{kind:EV_KEY, code:b0 as i32, ch:0, mods:M_CTRL, x:0,y:0,delta:0};
    }

    /* ESC: séquences, Alt+*, bracketed paste, souris */
    if b0 == KEY_ESC as u8 {
        let ev = parse_after_esc();
        if ev.kind != 0 { return ev; }
        return KeyEvent{kind:EV_KEY, code:KEY_ESC, ch:0, mods:0,x:0,y:0,delta:0};
    }

    /* UTF-8 multi-octets: tente un décodage minimal (2..4) */
    if (b0 & 0xE0u8) == 0xC0u8 || (b0 & 0xF0u8) == 0xE0u8 || (b0 & 0xF8u8) == 0xF0u8 {
        let (rune, _) = utf8_decode_follow(b0);
        let code = if rune <= 126 { rune as i32 } else { 0 };
        return KeyEvent{kind:EV_KEY, code:code, ch:rune, mods:0,x:0,y:0,delta:0};
    }

    /* Pass-through */
    return KeyEvent{kind:EV_KEY, code:b0 as i32, ch:b0 as u32, mods:0,x:0,y:0,delta:0};
}

/* Active le reporting souris (SGR 1006 + basic). */
fn term_enable_mouse(on: bool) {
    if on {
        print("\x1b[?1000;1002;1006h"); /* click+drag + SGR */
        TS.mouse_on = true;
    } else {
        print("\x1b[?1000;1002;1006l");
        TS.mouse_on = false;
    }
}

/* Bracketed paste 2004 */
fn term_enable_bracketed_paste(on: bool) {
    if on { print("\x1b[?2004h"); TS.paste_on=true; }
    else  { print("\x1b[?2004l"); TS.paste_on=false; }
}

/* Ecrit brut */
fn term_write_raw(buf: &[u8;1024], n: i32) -> i32 { return runtime_term_write(buf, n); }

/* -------------------- Décodage séquences --------------------------------- */

fn parse_after_esc() -> KeyEvent {
    /* lecture non bloquante du 2e octet */
    let mut b1:u8=0;
    if runtime_term_read_nb(&mut b1) <= 0 {
        return KeyEvent{kind:EV_KEY, code:KEY_ESC, ch:0, mods:0,x:0,y:0,delta:0};
    }

    /* CSI */
    if b1 == '[' as u8 { return parse_csi(); }
    /* SS3 / xterm 'O' pour F-keys/home/end */
    if b1 == 'O' as u8 { return parse_ss3(); }

    /* Bracketed paste begin/end: ESC [ 200~ / 201~ (rare). Officiellement via CSI 200~ */
    if b1 == '2' as u8 {
        /* pas standard: repoussé */
        push_byte(b1);
        return KeyEvent{kind:EV_KEY, code:KEY_ESC, ch:0, mods:0,x:0,y:0,delta:0};
    }

    /* Alt + char: si alt_esc, renvoie ESC puis char séparément
       Ici on retourne ESC en premier (déjà consommé). On remet le char pour la prochaine lecture. */
    if TS.alt_esc {
        push_byte(b1);
        return KeyEvent{kind:EV_KEY, code:KEY_ESC, ch:0, mods:0,x:0,y:0,delta:0};
    }

    /* Sinon: on tente de composer directement Alt+X -> EV_KEY avec M_ALT */
    return KeyEvent{kind:EV_KEY, code:b1 as i32, ch:b1 as u32, mods:M_ALT, x:0,y:0,delta:0};
}

fn parse_csi() -> KeyEvent {
    /* Lire jusqu’à un terminator lettre ou '~' */
    let mut buf:[u8;16]; let mut n=0;
    loop {
        let mut b:u8=0;
        let r = runtime_term_read_nb(&mut b);
        if r <= 0 { break; }
        if n < 16 { buf[n as usize] = b; n=n+1; }
        if (b >= 'A' as u8 && b <= 'Z' as u8) || (b >= 'a' as u8 && b <= 'z' as u8) || b=='~' as u8 {
            break;
        }
    }
    if n == 0 { return KeyEvent{kind:0,code:0,ch:0,mods:0,x:0,y:0,delta:0}; }

    let last = buf[(n-1) as usize];

    /* Flèches simples: A/B/C/D */
    if last == 'A' as u8 { return KeyEvent{kind:EV_KEY,code:K_UP,mods:0,ch:0,x:0,y:0,delta:0}; }
    if last == 'B' as u8 { return KeyEvent{kind:EV_KEY,code:K_DOWN,mods:0,ch:0,x:0,y:0,delta:0}; }
    if last == 'C' as u8 { return KeyEvent{kind:EV_KEY,code:K_RIGHT,mods:0,ch:0,x:0,y:0,delta:0}; }
    if last == 'D' as u8 { return KeyEvent{kind:EV_KEY,code:K_LEFT,mods:0,ch:0,x:0,y:0,delta:0}; }
    if last == 'H' as u8 { return KeyEvent{kind:EV_KEY,code:K_HOME,mods:0,ch:0,x:0,y:0,delta:0}; }
    if last == 'F' as u8 { return KeyEvent{kind:EV_KEY,code:K_END, mods:0,ch:0,x:0,y:0,delta:0}; }

    /* SGR mouse: CSI <btn> ; <x> ; <y> M/m */
    if last == 'M' as u8 || last == 'm' as u8 {
        return parse_csi_sgr_mouse(&buf, n, last);
    }

    /* Tildes: 1~ Home, 2~ Ins, 3~ Del, 4~ End, 5~ PgUp, 6~ PgDn, 11~..24~ F-keys */
    if last == '~' as u8 { return map_csi_tilde(&buf, n); }

    /* Bracketed paste 200~ / 201~ arrive via '~' ci-dessus. */
    return KeyEvent{kind:0,code:0,ch:0,mods:0,x:0,y:0,delta:0};
}

fn parse_ss3() -> KeyEvent {
    /* ESC O P..S pour F1..F4 ; ESC O H/F pour Home/End */
    let mut b:u8=0;
    if runtime_term_read_nb(&mut b) <= 0 { return KeyEvent{kind:0,code:0,ch:0,mods:0,x:0,y:0,delta:0}; }
    if b == 'P' as u8 { return KeyEvent{kind:EV_KEY,code:K_F1, ch:0,mods:0,x:0,y:0,delta:0}; }
    if b == 'Q' as u8 { return KeyEvent{kind:EV_KEY,code:K_F2, ch:0,mods:0,x:0,y:0,delta:0}; }
    if b == 'R' as u8 { return KeyEvent{kind:EV_KEY,code:K_F3, ch:0,mods:0,x:0,y:0,delta:0}; }
    if b == 'S' as u8 { return KeyEvent{kind:EV_KEY,code:K_F4, ch:0,mods:0,x:0,y:0,delta:0}; }
    if b == 'H' as u8 { return KeyEvent{kind:EV_KEY,code:K_HOME,mods:0,ch:0,x:0,y:0,delta:0}; }
    if b == 'F' as u8 { return KeyEvent{kind:EV_KEY,code:K_END, mods:0,ch:0,x:0,y:0,delta:0}; }
    return KeyEvent{kind:0,code:0,ch:0,mods:0,x:0,y:0,delta:0};
}

fn map_csi_tilde(buf: &[u8;16], n: i32) -> KeyEvent {
    /* Extraire le nombre avant '~' et éventuellement 200/201 paste */
    let mut i=0; let mut val=0;
    while i<n {
        let b = buf[i as usize];
        if b >= '0' as u8 && b <= '9' as u8 { val = val*10 + ((b - '0' as u8) as i32); }
        if b == '~' as u8 { break; }
        i=i+1;
    }
    if val == 1 || val==7  { return KeyEvent{kind:EV_KEY,code:K_HOME,mods:0,ch:0,x:0,y:0,delta:0}; }
    if val == 2           { return KeyEvent{kind:EV_KEY,code:K_INS, mods:0,ch:0,x:0,y:0,delta:0}; }
    if val == 3           { return KeyEvent{kind:EV_KEY,code:KEY_DEL,mods:0,ch:0,x:0,y:0,delta:0}; }
    if val == 4 || val==8 { return KeyEvent{kind:EV_KEY,code:K_END, mods:0,ch:0,x:0,y:0,delta:0}; }
    if val == 5           { return KeyEvent{kind:EV_KEY,code:K_PGUP,mods:0,ch:0,x:0,y:0,delta:0}; }
    if val == 6           { return KeyEvent{kind:EV_KEY,code:K_PGDN,mods:0,ch:0,x:0,y:0,delta:0}; }
    if val == 11 { return KeyEvent{kind:EV_KEY,code:K_F1, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 12 { return KeyEvent{kind:EV_KEY,code:K_F2, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 13 { return KeyEvent{kind:EV_KEY,code:K_F3, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 14 { return KeyEvent{kind:EV_KEY,code:K_F4, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 15 { return KeyEvent{kind:EV_KEY,code:K_F5, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 17 { return KeyEvent{kind:EV_KEY,code:K_F6, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 18 { return KeyEvent{kind:EV_KEY,code:K_F7, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 19 { return KeyEvent{kind:EV_KEY,code:K_F8, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 20 { return KeyEvent{kind:EV_KEY,code:K_F9, ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 21 { return KeyEvent{kind:EV_KEY,code:K_F10,ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 23 { return KeyEvent{kind:EV_KEY,code:K_F11,ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 24 { return KeyEvent{kind:EV_KEY,code:K_F12,ch:0,mods:0,x:0,y:0,delta:0}; }

    /* Bracketed paste (officiel via CSI 200~ début, 201~ fin) */
    if val == 200 { return KeyEvent{kind:EV_PASTE,code:PASTE_BEGIN,ch:0,mods:0,x:0,y:0,delta:0}; }
    if val == 201 { return KeyEvent{kind:EV_PASTE,code:PASTE_END,  ch:0,mods:0,x:0,y:0,delta:0}; }
    return KeyEvent{kind:0,code:0,ch:0,mods:0,x:0,y:0,delta:0};
}

fn parse_csi_sgr_mouse(buf:&[u8;16], n:i32, term:u8) -> KeyEvent {
    /* Format: CSI <btn> ; <x> ; <y> M/m (M=press/move, m=release) */
    let mut i=0; let mut field=0; let mut v=0;
    let mut btn=0; let mut x=0; let mut y=0;
    while i<n {
        let b = buf[i as usize];
        if b >= '0' as u8 && b <= '9' as u8 { v = v*10 + ((b-'0' as u8) as i32); }
        if b == ';' as u8 || i==n-1 {
            if field==0 { btn=v; } else if field==1 { x=v; } else { y=v; }
            field=field+1; v=0;
        }
        i=i+1;
    }
    let pressed = term == 'M' as u8;
    /* btn bitfield xterm SGR: lower bits button, 32 move, 64 wheel, 8 shift,16 alt,4 ctrl */
    let mods = ((btn & 4)!=0 ? M_CTRL : 0) | ((btn & 8)!=0 ? M_SHIFT:0) | ((btn & 16)!=0 ? M_ALT:0);
    if (btn & 64) != 0 {
        /* wheel: 0 up, 1 down (with 64 added), some terms 64+ */
        let wheel = if (btn & 1) != 0 { -1 } else { 1 };
        return KeyEvent{kind:EV_MOUSE, code:MOUSE_WHEEL, ch:0, mods:mods, x:x, y:y, delta:wheel};
    }
    if (btn & 32) != 0 {
        return KeyEvent{kind:EV_MOUSE, code:MOUSE_MOVE, ch:0, mods:mods, x:x, y:y, delta:0};
    }
    let which = btn & 3;
    let kind = if pressed { MOUSE_DOWN } else { MOUSE_UP };
    /* which=0 left,1 middle,2 right */
    return KeyEvent{kind:EV_MOUSE, code:kind + which, ch:0, mods:mods, x:x, y:y, delta:0};
}

/* -------------------- UTF-8 minimal -------------------------------------- */

fn utf8_decode_follow(b0:u8) -> (u32, i32) {
    let mut rune:u32 = 0;
    if (b0 & 0xE0u8) == 0xC0u8 {
        let mut b1:u8=0; if runtime_term_read_nb(&mut b1) <= 0 { return ('?' as u32,1); }
        rune = ((b0 & 0x1Fu8) as u32)<<6 | ((b1 & 0x3Fu8) as u32);
        return (rune, 2);
    }
    if (b0 & 0xF0u8) == 0xE0u8 {
        let mut b1:u8=0; let mut b2:u8=0;
        if runtime_term_read_nb(&mut b1) <= 0 || runtime_term_read_nb(&mut b2) <= 0 { return ('?' as u32,1); }
        rune = ((b0 & 0x0Fu8) as u32)<<12 | ((b1 & 0x3Fu8) as u32)<<6 | ((b2 & 0x3Fu8) as u32);
        return (rune, 3);
    }
    if (b0 & 0xF8u8) == 0xF0u8 {
        let mut b1:u8=0; let mut b2:u8=0; let mut b3:u8=0;
        if runtime_term_read_nb(&mut b1) <= 0 || runtime_term_read_nb(&mut b2) <= 0 || runtime_term_read_nb(&mut b3) <= 0 { return ('?' as u32,1); }
        rune = ((b0 & 0x07u8) as u32)<<18 | ((b1 & 0x3Fu8) as u32)<<12 | ((b2 & 0x3Fu8) as u32)<<6 | ((b3 & 0x3Fu8) as u32);
        return (rune, 4);
    }
    return (b0 as u32, 1);
}

/* -------------------- Helpers lecture ------------------------------------ */

fn read_byte(out:&mut u8, timeout_ms:i32) -> bool {
    if TS.push_n > 0 {
        TS.push_n = TS.push_n - 1;
        *out = TS.push[TS.push_n as usize];
        return true;
    }
    let ok = runtime_term_poll(timeout_ms);
    if ok == 0 { return false; }
    if ok < 0 { return false; }
    let n = runtime_term_read1(out);
    return n > 0;
}

fn push_byte(b:u8) {
    if TS.push_n < 16 { TS.push[TS.push_n as usize] = b; TS.push_n = TS.push_n + 1; }
}

/* -------------------- Utilitaires debug ---------------------------------- */

fn key_to_label(code: i32, out:&mut [u8;32]) -> i32 {
    if code >= 32 && code <= 126 { out[0]=code as u8; out[1]=0; return 1; }
    return copy_label(map_name(code), out);
}
fn map_name(code:i32) -> str {
    if code==KEY_ESC { return "ESC"; }
    if code==KEY_TAB { return "TAB"; }
    if code==KEY_CR  { return "CR"; }
    if code==KEY_LF  { return "LF"; }
    if code==KEY_BS  { return "BS"; }
    if code==KEY_DEL { return "DEL"; }
    if code==K_UP    { return "UP"; }
    if code==K_DOWN  { return "DOWN"; }
    if code==K_LEFT  { return "LEFT"; }
    if code==K_RIGHT { return "RIGHT"; }
    if code==K_HOME  { return "HOME"; }
    if code==K_END   { return "END"; }
    if code==K_PGUP  { return "PGUP"; }
    if code==K_PGDN  { return "PGDN"; }
    if code==K_INS   { return "INS"; }
    if code==K_F1 {return "F1";} if code==K_F2 {return "F2";} if code==K_F3 {return "F3";}
    if code==K_F4 {return "F4";} if code==K_F5 {return "F5";} if code==K_F6 {return "F6";}
    if code==K_F7 {return "F7";} if code==K_F8 {return "F8";} if code==K_F9 {return "F9";}
    if code==K_F10 {return "F10";} if code==K_F11 {return "F11";} if code==K_F12 {return "F12";}
    return "?";
}
fn copy_label(s:str, out:&mut [u8;32]) -> i32 {
    let L = min(strlen_ascii(s), 31); let mut i=0;
    while i<L { out[i as usize] = s[i as usize] as u8; i=i+1; }
    out[L as usize]=0; return L;
}
fn min(a:i32,b:i32)->i32{ if a<b {return a;} return b; }

/* -------------------- Hooks backend (à implémenter) ---------------------- */

fn runtime_term_enable_raw() { }
fn runtime_term_disable_raw() { }
fn runtime_term_set_echo(_on:i32) { }

fn runtime_term_poll(_timeout_ms:i32) -> i32 { return 0; }  /* 1 prêt, 0 timeout, <0 err */
fn runtime_term_read1(_out:&mut u8) -> i32 { return 0; }    /* 1 si lu, 0 sinon, <0 err */
fn runtime_term_read_nb(_out:&mut u8) -> i32 { return 0; }  /* non-bloquant */
fn runtime_term_write(_buf:&[u8;1024], _n:i32) -> i32 { return 0; }

fn runtime_term_flush() { }
fn runtime_term_size(_rows:&mut i32, _cols:&mut i32) { }

/* -------------------- Stubs std utilisés --------------------------------- */

fn print(_s:str) { }
fn strlen_ascii(_s:str)->i32 { return 0; }

/* -------------------- Exemple d’usage (commenté) --------------------------
fn main() -> i32 {
    term_enable_raw();
    term_enable_mouse(true);
    term_enable_bracketed_paste(true);
    println("Lecture evts. ESC deux fois pour quitter.");
    let mut escs=0;
    loop {
        let ev = term_read_event(-1);
        if ev.kind==EV_KEY && ev.code==KEY_ESC {
            escs=escs+1; if escs>=2 { break; }
        } else { escs=0; }

        /* Affiche label simple */
        let mut b:[u8;32]; let _=key_to_label(ev.code,&mut b);
        runtime_term_write(&b, cstr_len(&b));
        runtime_term_write(&[10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],1);
    }
    term_disable_raw();
    return 0;
}
fn cstr_len(p:&[u8;32])->i32{let mut i=0;while i<32{if p[i as usize]==0{return i;}i=i+1;}return 32;}
---------------------------------------------------------------------------- */