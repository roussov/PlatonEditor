/* ============================================================================
   syntax.vitte — Coloration syntaxique ultra-compacte pour Platon Editor
   - Zéro alloc dyn. Buffers statiques bornés.
   - Langages intégrés: "vitte", "json", "ini", "md" (markdown light), "plain".
   - Lexer incrémental par ligne avec état multi-ligne (block comments, strings).
   - Sortie: spans (col_start, col_end, style_id) et/ou ANSI direct.
   - Styles: 0..15 mappés vers codes ANSI (fg/bg/attribs) configurables.
   - Hooks: runtime_term_write, print, strlen_ascii.
   - Intégration: appeler syntax_line() pour chaque ligne, garder SyntaxState par buffer.
   ============================================================================ */

const MAX_COLS:    i32 = 256;
const MAX_SPANS:   i32 = 64;
const MAX_KW:      i32 = 128;
const MAX_KW_LEN:  i32 = 24;

/* ----------------------------- Styles ------------------------------------ */
/* Table style 0..15 -> séquence ANSI courte sans ‘m’ final (ex: "1;34").   */
struct StyleTable { items: [Style; 16] }
struct Style { seq: [u8; 16], len: i32 } /* "1;34" => \x1b[1;34m */

const S_DEFAULT:     i32 = 0;  /* texte normal */
const S_KEYWORD:     i32 = 1;  /* mots-clés */
const S_TYPE:        i32 = 2;  /* types/builtins */
const S_IDENT:       i32 = 3;  /* identifiants */
const S_NUMBER:      i32 = 4;  /* nombres */
const S_STRING:      i32 = 5;  /* chaînes */
const S_CHAR:        i32 = 6;  /* char lit */
const S_COMMENT:     i32 = 7;  /* commentaires */
const S_PUNC:        i32 = 8;  /* ponctuation/brackets */
const S_DIRECTIVE:   i32 = 9;  /* #define, @, section[] */
const S_HEADING:     i32 = 10; /* markdown headings */
const S_EMPH:        i32 = 11; /* markdown *em* */
const S_LINK:        i32 = 12; /* urls/link */
const S_BOOL_NULL:   i32 = 13; /* true/false/null */
const S_FIELD:       i32 = 14; /* cles ini/json prop */
const S_ERROR:       i32 = 15; /* erreurs lexer */

fn style_defaults(t:&mut StyleTable) {
    set_style(t, S_DEFAULT,    "0");
    set_style(t, S_KEYWORD,    "1;35");
    set_style(t, S_TYPE,       "1;36");
    set_style(t, S_IDENT,      "0;37");
    set_style(t, S_NUMBER,     "0;33");
    set_style(t, S_STRING,     "0;32");
    set_style(t, S_CHAR,       "0;32");
    set_style(t, S_COMMENT,    "0;90");
    set_style(t, S_PUNC,       "0;37");
    set_style(t, S_DIRECTIVE,  "1;34");
    set_style(t, S_HEADING,    "1;34");
    set_style(t, S_EMPH,       "3;37");
    set_style(t, S_LINK,       "4;36");
    set_style(t, S_BOOL_NULL,  "1;33");
    set_style(t, S_FIELD,      "1;37");
    set_style(t, S_ERROR,      "1;31");
}
fn set_style(t:&mut StyleTable, idx:i32, seq:str) {
    let mut k=0; let L=min(strlen_ascii(seq), 15);
    while k<L { t.items[idx as usize].seq[k as usize] = seq[k as usize] as u8; k=k+1; }
    t.items[idx as usize].len = L;
}

/* ----------------------------- API sortie -------------------------------- */

struct Span { a:i32, b:i32, s:i32 } /* [a,b) -> style s */

struct LineOut {
    n: i32,
    spans: [Span; MAX_SPANS],
}

/* ----------------------------- État global -------------------------------- */

struct KeywordSet {
    n:i32, lens:[i32; MAX_KW], data:[[u8; MAX_KW_LEN]; MAX_KW],
}
fn kw_clear(k:&mut KeywordSet){ k.n=0; let mut i=0; while i<MAX_KW { k.lens[i as usize]=0; i=i+1; } }
fn kw_add(k:&mut KeywordSet, w:str){
    if k.n>=MAX_KW { return; }
    let L=min(strlen_ascii(w), MAX_KW_LEN);
    if L<=0 { return; }
    let i=k.n;
    let mut j=0; while j<L { k.data[i as usize][j as usize]=w[j as usize] as u8; j=j+1; }
    k.lens[i as usize]=L; k.n=i+1;
}
fn kw_match(k:&KeywordSet, buf:&[u8;MAX_COLS], start:i32, end:i32)->i32{
    let len=end-start; if len<=0 { return -1; }
    let mut i=0;
    while i<k.n {
        if k.lens[i as usize]==len {
            let mut ok=true; let mut j=0;
            while j<len { if k.data[i as usize][j as usize]!=buf[(start+j) as usize] { ok=false; break; } j=j+1; }
            if ok { return i; }
        }
        i=i+1;
    }
    return -1;
}

/* ----------------------------- Langue/état -------------------------------- */

const L_PLAIN:i32=0; const L_VITTE:i32=1; const L_JSON:i32=2; const L_INI:i32=3; const L_MD:i32=4;

struct SyntaxState {
    lang:i32,
    style: StyleTable,

    /* états multi-lignes */
    in_block_comment: bool,    /* vitte: /* ... */ */
    in_string: i32,            /* 0 none, 1 " .., 2 ' .., 3 ` .. */
    str_is_raw: bool,          /* json/vitte raw/backtick */

    /* markdown */
    md_in_codeblock: bool,     /* ``` ... ``` */

    /* mots-clés */
    kw: KeywordSet,            /* keywords */
    kt: KeywordSet,            /* types/builtins */
}

fn syntax_init(s:&mut SyntaxState, lang:str){
    s.lang = pick_lang(lang);
    style_defaults(&mut s.style);
    s.in_block_comment=false; s.in_string=0; s.str_is_raw=false;
    s.md_in_codeblock=false;
    kw_clear(&mut s.kw); kw_clear(&mut s.kt);
    if s.lang==L_VITTE { load_kw_vitte(&mut s.kw, &mut s.kt); }
    if s.lang==L_JSON  { load_kw_json(&mut s.kw); }
    if s.lang==L_INI   { /* no kw */ }
    if s.lang==L_MD    { /* no kw */ }
}

fn pick_lang(name:str)->i32{
    if equals(name,"vitte") { return L_VITTE; }
    if equals(name,"json")  { return L_JSON; }
    if equals(name,"ini")   { return L_INI; }
    if equals(name,"md") || equals(name,"markdown") { return L_MD; }
    return L_PLAIN;
}

fn syntax_set_style(s:&mut SyntaxState, idx:i32, seq:str){ set_style(&mut s.style, idx, seq); }
fn syntax_add_keyword(s:&mut SyntaxState, w:str){ kw_add(&mut s.kw, w); }
fn syntax_add_type(s:&mut SyntaxState, w:str){ kw_add(&mut s.kt, w); }

/* ----------------------------- Lexing utils ------------------------------- */

fn is_alpha(b:u8)->bool{ return (b>=b'a' && b<=b'z') || (b>=b'A' && b<=b'Z') || b==b'_' || b==b'$'; }
fn is_digit(b:u8)->bool{ return b>=b'0' && b<=b'9'; }
fn is_xdigit(b:u8)->bool{ return is_digit(b) || (b>=b'a'&&b<=b'f') || (b>=b'A'&&b<=b'F'); }
fn is_ident_body(b:u8)->bool{ return is_alpha(b) || is_digit(b); }
fn is_space(b:u8)->bool{ return b==b' ' || b==b'\t'; }

fn equals(a:str, b:str)->bool{
    let la=strlen_ascii(a); let lb=strlen_ascii(b); if la!=lb { return false; }
    let mut i=0; while i<la { if a[i as usize]!=b[i as usize] { return false; } i=i+1; }
    return true;
}

fn push_span(out:&mut LineOut, a:i32, b:i32, st:i32){
    if a>=b { return; }
    if out.n>=MAX_SPANS { return; }
    out.spans[out.n as usize] = Span{a:a,b:b,s:st};
    out.n = out.n + 1;
}

/* ----------------------------- Lexer par langue --------------------------- */

fn syntax_line(s:&mut SyntaxState, line:&[u8;MAX_COLS], len:i32, out:&mut LineOut){
    out.n=0;
    if s.lang==L_PLAIN { push_span(out, 0, len, S_DEFAULT); return; }
    if s.lang==L_JSON  { lex_json(s, line, len, out); return; }
    if s.lang==L_INI   { lex_ini(s, line, len, out); return; }
    if s.lang==L_MD    { lex_md(s, line, len, out); return; }
    /* default vitte-like C-style */
    lex_vitte(s, line, len, out);
}

/* ---- vitte: // comment, /* */ comment, " ' ` strings, 0x, 0b, 123_456 ---- */

fn lex_vitte(st:&mut SyntaxState, b:&[u8;MAX_COLS], n:i32, out:&mut LineOut){
    let mut i=0; let mut seg_a=0; let mut cur=S_DEFAULT;

    if st.in_block_comment {
        let mut j=0; /* chercher */ 
        while i<n-1 {
            if b[i as usize]==b'*' && b[(i+1) as usize]==b'/' { push_span(out,0, i+2, S_COMMENT); st.in_block_comment=false; i=i+2; seg_a=i; break; }
            i=i+1;
        }
        if st.in_block_comment { push_span(out,0,n,S_COMMENT); return; }
    }
    i=seg_a;

    while i<n {
        let c=b[i as usize];

        /* line comment */
        if c==b'/' && i+1<n && b[(i+1) as usize]==b'/' {
            if seg_a<i { push_span(out, seg_a, i, cur); }
            push_span(out, i, n, S_COMMENT);
            return;
        }
        /* block comment start */
        if c==b'/' && i+1<n && b[(i+1) as usize]==b'*' {
            if seg_a<i { push_span(out, seg_a, i, cur); }
            /* chercher fin sur même ligne sinon persiste */
            let mut j=i+2; let mut closed=false;
            while j<n-1 {
                if b[j as usize]==b'*' && b[(j+1) as usize]==b'/' { push_span(out,i,j+2,S_COMMENT); i=j+2; seg_a=i; closed=true; break; }
                j=j+1;
            }
            if !closed { push_span(out,i,n,S_COMMENT); st.in_block_comment=true; return; }
            continue;
        }
        /* strings " ' ` */
        if c==b'"' || c==b'\'' || c==b'`' {
            if seg_a<i { push_span(out, seg_a, i, cur); }
            let typ = if c==b'"' {1} else if c==b'\'' {2} else {3};
            let mut j=i+1; let mut esc=false;
            while j<n {
                let d=b[j as usize];
                if typ!=3 && !esc && d==b'\\' { esc=true; j=j+1; continue; }
                if !esc && d==c { j=j+1; break; }
                esc=false; j=j+1;
            }
            if j>n { j=n; }
            push_span(out, i, j, if typ==2 { S_CHAR } else { S_STRING });
            i=j; seg_a=i; cur=S_DEFAULT; continue;
        }

        /* numbers */
        if is_digit(c) || (c==b'.' && i+1<n && is_digit(b[(i+1) as usize])) {
            if seg_a<i { push_span(out, seg_a, i, cur); }
            let mut j=i;
            if c==b'0' && i+1<n && (b[(i+1) as usize]==b'x' || b[(i+1) as usize]==b'X') {
                j=j+2; while j<n && (is_xdigit(b[j as usize]) || b[j as usize]==b'_') { j=j+1; }
            } else if c==b'0' && i+1<n && (b[(i+1) as usize]==b'b' || b[(i+1) as usize]==b'B') {
                j=j+2; while j<n && (b[j as usize]==b'0' || b[j as usize]==b'1' || b[j as usize]==b'_') { j=j+1; }
            } else {
                while j<n && (is_digit(b[j as usize]) || b[j as usize]==b'_') { j=j+1; }
                if j<n && b[j as usize]==b'.' { j=j+1; while j<n && is_digit(b[j as usize]) { j=j+1; } }
                if j<n && (b[j as usize]==b'e' || b[j as usize]==b'E') {
                    j=j+1; if j<n && (b[j as usize]==b'+'||b[j as usize]==b'-'){ j=j+1; }
                    while j<n && is_digit(b[j as usize]) { j=j+1; }
                }
            }
            push_span(out, i, j, S_NUMBER); i=j; seg_a=i; cur=S_DEFAULT; continue;
        }

        /* identifiers / keywords / types */
        if is_alpha(c) {
            if seg_a<i { push_span(out, seg_a, i, cur); }
            let mut j=i+1; while j<n && is_ident_body(b[j as usize]) { j=j+1; }
            let kw = kw_match(&st.kw, b, i, j);
            if kw>=0 { push_span(out,i,j,S_KEYWORD); }
            else {
                let ty = kw_match(&st.kt, b, i, j);
                if ty>=0 { push_span(out,i,j,S_TYPE); }
                else if (j-i==4 && eq4(b,i,"true")) || (j-i==5 && eq5(b,i,"false")) || (j-i==4 && eq4(b,i,"null")) {
                    push_span(out,i,j,S_BOOL_NULL);
                } else { push_span(out,i,j,S_IDENT); }
            }
            i=j; seg_a=i; cur=S_DEFAULT; continue;
        }

        /* directives (#, @) */
        if c==b'#' || c==b'@' {
            if seg_a<i { push_span(out,seg_a,i,cur); }
            let mut j=i+1; while j<n && !is_space(b[j as usize]) { j=j+1; }
            push_span(out, i, j, S_DIRECTIVE); i=j; seg_a=i; continue;
        }

        /* punctuation */
        if is_punc(c) {
            if seg_a<i { push_span(out,seg_a,i,cur); }
            push_span(out, i, i+1, S_PUNC);
            i=i+1; seg_a=i; continue;
        }

        i=i+1;
    }
    if seg_a<n { push_span(out, seg_a, n, cur); }
}

fn is_punc(c:u8)->bool{
    return c==b'('||c==b')'||c==b'{'||c==b'}'||c==b'['||c==b']'
        || c==b','||c==b';'||c==b':'||c==b'.'||c==b'+'||c==b'-'
        || c==b'*'||c==b'/'||c==b'%'||c==b'!'||c==b'='||c==b'<'||c==b'>'
        || c==b'&'||c==b'|'||c==b'^'||c==b'~'||c==b'?';
}

/* helpers eqN */
fn eq4(b:&[u8;MAX_COLS],i:i32,s4:str)->bool{ return b[i as usize]==s4[0] as u8 && b[(i+1) as usize]==s4[1] as u8 && b[(i+2) as usize]==s4[2] as u8 && b[(i+3) as usize]==s4[3] as u8; }
fn eq5(b:&[u8;MAX_COLS],i:i32,s5:str)->bool{ return eq4(b,i,s5) && b[(i+4) as usize]==s5[4] as u8; }

/* ----------------------------- JSON -------------------------------------- */

fn lex_json(st:&mut SyntaxState, b:&[u8;MAX_COLS], n:i32, out:&mut LineOut){
    let mut i=0; let mut seg=i; let mut in_key=false;
    while i<n {
        let c=b[i as usize];
        /* whitespace */
        if c==b' '||c==b'\t'||c==b'\r' {
            i=i+1; continue;
        }
        /* colon toggles key->value */
        if c==b':' { push_span(out,i,i+1,S_PUNC); i=i+1; in_key=false; continue; }
        if c==b','||c==b'{'||c==b'}'||c==b'['||c==b']' {
            push_span(out,i,i+1,S_PUNC); i=i+1; continue;
        }
        /* string */
        if c==b'"' {
            let (j, is_key) = json_string(b, n, i);
            push_span(out, i, j, if in_key || is_key { S_FIELD } else { S_STRING });
            i=j; continue;
        }
        /* numbers */
        if c==b'-' || is_digit(c) {
            let j = json_number(b, n, i);
            push_span(out, i, j, S_NUMBER); i=j; continue;
        }
        /* true/false/null */
        if match_word(b,n,i,"true"){ push_span(out,i,i+4,S_BOOL_NULL); i=i+4; continue; }
        if match_word(b,n,i,"false"){ push_span(out,i,i+5,S_BOOL_NULL); i=i+5; continue; }
        if match_word(b,n,i,"null"){ push_span(out,i,i+4,S_BOOL_NULL); i=i+4; continue; }

        /* unknown */
        push_span(out,i,i+1,S_ERROR); i=i+1;
    }
}

fn json_string(b:&[u8;MAX_COLS], n:i32, i0:i32)->(i32,bool){
    let mut i=i0+1; let mut esc=false; let mut is_key=false;
    while i<n {
        let c=b[i as usize];
        if !esc && c==b'\\' { esc=true; i=i+1; continue; }
        if !esc && c==b'"' {
            /* regarde si prochain non-espace est ':' => c’était une clé */
            let mut k=i+1; while k<n && (b[k as usize]==b' '||b[k as usize]==b'\t') { k=k+1; }
            if k<n && b[k as usize]==b':' { is_key=true; }
            return (i+1, is_key);
        }
        esc=false; i=i+1;
    }
    return (n, false);
}
fn json_number(b:&[u8;MAX_COLS], n:i32, i0:i32)->i32{
    let mut i=i0;
    if b[i as usize]==b'-' { i=i+1; }
    while i<n && is_digit(b[i as usize]) { i=i+1; }
    if i<n && b[i as usize]==b'.' { i=i+1; while i<n && is_digit(b[i as usize]) { i=i+1; } }
    if i<n && (b[i as usize]==b'e'||b[i as usize]==b'E') {
        i=i+1; if i<n && (b[i as usize]==b'+'||b[i as usize]==b'-'){ i=i+1; }
        while i<n && is_digit(b[i as usize]) { i=i+1; }
    }
    return i;
}
fn match_word(b:&[u8;MAX_COLS], n:i32, i:i32, w:str)->bool{
    let L=strlen_ascii(w); if i+L>n { return false; }
    let mut k=0; while k<L { if b[(i+k) as usize]!=w[k as usize] as u8 { return false; } k=k+1; }
    true
}

/* ----------------------------- INI --------------------------------------- */

fn lex_ini(_:&mut SyntaxState, b:&[u8;MAX_COLS], n:i32, out:&mut LineOut){
    let mut i=0;
    if n>0 && b[0]==b';' { push_span(out,0,n,S_COMMENT); return; }
    /* section [name] */
    if n>0 && b[0]==b'[' {
        let mut j=1; while j<n && b[j as usize]!=b']' { j=j+1; }
        if j<n { push_span(out,0,j+1,S_DIRECTIVE); if j+1<n { push_span(out,j+1,n,S_DEFAULT); } }
        else { push_span(out,0,n,S_DIRECTIVE); }
        return;
    }
    /* key = value ; comment */
    while i<n && b[i as usize]!=b'=' && b[i as usize]!=b';' { i=i+1; }
    if i<n && b[i as usize]==b'=' {
        /* key */
        trim_left(out, b, 0, i, S_FIELD);
        push_span(out, i, i+1, S_PUNC);
        /* value */
        let mut j=i+1; while j<n && b[j as usize]!=b';' { j=j+1; }
        push_span(out, i+1, j, S_STRING);
        if j<n { push_span(out, j, n, S_COMMENT); }
        return;
    }
    /* no '=' -> plain or comment */
    let mut k=0; while k<n && (b[k as usize]==b' '||b[k as usize]==b'\t') { k=k+1; }
    if k<n && b[k as usize]==b';' { push_span(out,k,n,S_COMMENT); if k>0 { push_span(out,0,k,S_DEFAULT);} return; }
    push_span(out,0,n,S_DEFAULT);
}

fn trim_left(out:&mut LineOut, b:&[u8;MAX_COLS], a:i32, e:i32, st:i32){
    let mut i=a; while i<e && (b[i as usize]==b' '||b[i as usize]==b'\t'){ i=i+1; }
    let mut j=e; while j>i && (b[(j-1) as usize]==b' '||b[(j-1) as usize]==b'\t'){ j=j-1; }
    if j>i { push_span(out,i,j,st); }
}

/* ----------------------------- Markdown light ---------------------------- */

fn lex_md(st:&mut SyntaxState, b:&[u8;MAX_COLS], n:i32, out:&mut LineOut){
    if n>=3 && b[0]==b'`' && b[1]==b'`' && b[2]==b'`' {
        /* toggle code fence */
        push_span(out,0,n,S_DIRECTIVE);
        st.md_in_codeblock = !st.md_in_codeblock;
        return;
    }
    if st.md_in_codeblock { push_span(out,0,n,S_STRING); return; }

    /* heading */
    let mut i=0; let mut hashes=0;
    while i<n && b[i as usize]==b'#' { hashes=hashes+1; i=i+1; }
    if hashes>0 && (i<n && b[i as usize]==b' ') {
        push_span(out,0,n,S_HEADING); return;
    }

    /* links [text](url), emphasis *em* or _em_ */
    let mut p=0;
    while p<n {
        if b[p as usize]==b'[' {
            let mut q=p+1; while q<n && b[q as usize]!=b']' { q=q+1; }
            if q<n && q+1<n && b[(q+1) as usize]==b'(' {
                let mut r=q+2; while r<n && b[r as usize]!=b')' { r=r+1; }
                if r<n {
                    push_span(out,p,q+1,S_EMPH);
                    push_span(out,q+1,r+1,S_LINK);
                    p=r+1; continue;
                }
            }
        }
        if b[p as usize]==b'*' || b[p as usize]==b'_' {
            let mark=b[p as usize]; let mut q=p+1;
            while q<n && b[q as usize]!=mark { q=q+1; }
            if q<n { push_span(out,p,q+1,S_EMPH); p=q+1; continue; }
        }
        p=p+1;
    }
    if out.n==0 { push_span(out,0,n,S_DEFAULT); }
}

/* ----------------------------- ANSI rendu -------------------------------- */

fn syntax_print_ansi(st:&SyntaxState, b:&[u8;MAX_COLS], n:i32, out:&LineOut){
    let mut i=0;
    let mut si=0;
    while si<out.n {
        let sp = out.spans[si as usize];
        if sp.a>i { runtime_term_write_slice(b, i, sp.a); }
        apply_style(&st.style, sp.s);
        runtime_term_write_slice(b, sp.a, sp.b);
        reset_style();
        i = sp.b; si=si+1;
    }
    if i<n { runtime_term_write_slice(b, i, n); }
}

fn apply_style(t:&StyleTable, s:i32){
    print("\x1b["); runtime_term_write(&t.items[s as usize].seq, t.items[s as usize].len); print("m");
}
fn reset_style(){ print("\x1b[0m"); }

/* write slice raw */
fn runtime_term_write_slice(buf:&[u8;MAX_COLS], a:i32, b:i32){
    let mut tmp:[u8;MAX_COLS]; let mut k=0; let mut i=a;
    while i<b { tmp[k as usize]=buf[i as usize]; k=k+1; i=i+1; }
    runtime_term_write(&tmp, k);
}

/* ----------------------------- Keywords par défaut ----------------------- */

fn load_kw_vitte(kw:&mut KeywordSet, kt:&mut KeywordSet){
    /* mots-clés */
    kw_add(kw,"const"); kw_add(kw,"struct"); kw_add(kw,"fn"); kw_add(kw,"return");
    kw_add(kw,"let"); kw_add(kw,"mut"); kw_add(kw,"if"); kw_add(kw,"else");
    kw_add(kw,"while"); kw_add(kw,"for"); kw_add(kw,"break"); kw_add(kw,"continue");
    kw_add(kw,"true"); kw_add(kw,"false"); kw_add(kw,"match");
    /* types/builtins */
    kw_add(kt,"i32"); kw_add(kt,"i64"); kw_add(kt,"u8"); kw_add(kt,"u32"); kw_add(kt,"bool");
    kw_add(kt,"str"); kw_add(kt,"char"); kw_add(kt,"f32"); kw_add(kt,"f64");
}

fn load_kw_json(kw:&mut KeywordSet){
    kw_add(kw,"true"); kw_add(kw,"false"); kw_add(kw,"null");
}

/* ----------------------------- Intégration rapide ------------------------ */
/* Exemple:
   let mut sx=SyntaxState{...}; syntax_init(&mut sx,"vitte");
   let mut out=LineOut{n:0,spans:[Span{a:0,b:0,s:0};MAX_SPANS]};
   syntax_line(&mut sx, &line, line_len, &mut out);
   syntax_print_ansi(&sx, &line, line_len, &out);
*/

/* ----------------------------- Utils/Std --------------------------------- */

fn min(a:i32,b:i32)->i32{ if a<b {return a;} return b; }
fn strlen_ascii(_s:str)->i32{ return 0; }
fn print(_s:str){}
fn runtime_term_write(_buf:&[u8;MAX_COLS], _n:i32)->i32{ return 0; }