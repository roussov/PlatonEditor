/* ============================================================================
   Pathfinder BFS — Vitte demo (~150 lignes, version complète)
   - Grille ASCII : '#' mur, '.' libre, 'S' départ, 'E' arrivée
   - BFS sans allocations dynamiques (files et parents statiques)
   - Affiche le chemin le plus court si atteignable
   - Zéro dépendance: conversions et impressions intégrées.
   ============================================================================ */

const W: i32 = 16;
const H: i32 = 10;
const N: i32 = W * H;

/* Codes ASCII utiles */
const C_WALL: u8 = 35;  /* '#' */
const C_FREE: u8 = 46;  /* '.' */
const C_S:    u8 = 83;  /* 'S' */
const C_E:    u8 = 69;  /* 'E' */
const C_P:    u8 = 42;  /* '*' */
const C_Q:    u8 = 63;  /* '?' */

/* --- Types --------------------------------------------------------------- */

struct Point { x: i32, y: i32 }

/* --- Helpers coordonnées ------------------------------------------------- */

fn idx(x: i32, y: i32) -> i32 { return y * W + x; }

fn in_bounds(x: i32, y: i32) -> bool {
    return x >= 0 && y >= 0 && x < W && y < H;
}

/* --- Grille de test ------------------------------------------------------ */
/* S et E sont uniques. Ajuste la carte selon tes besoins. */
fn make_grid(out: &mut [u8; N]) {
    let rows: [str; H] = [
        "################",
        "#S.....#.......#",
        "###.#.##.#####.#",
        "#...#....#...#.#",
        "#.#.#####.#.#..#",
        "#.#.....#.#.##.#",
        "#.#####.#.#....#",
        "#.....#.#.####.#",
        "#.###.#...#..E.#",
        "################",
    ];
    let mut k: i32 = 0;
    for y in 0..H {
        let line = rows[y as usize];
        for x in 0..W {
            out[k as usize] = as_u8(char_at(line, x));
            k = k + 1;
        }
    }
}

/* Indexation caractères ASCII d’une chaîne (suppose longueur >= i+1) */
fn char_at(s: str, i: i32) -> char {
    /* Implémentation simple par indexation directe selon la grammaire Vitte */
    return s[i as usize];
}

/* Petite conversion rune->u8 (assume ASCII) */
fn as_u8(c: char) -> u8 { return (c as u32) as u8; }

/* --- BFS sur grille ------------------------------------------------------ */

fn bfs_shortest_path(grid: &[u8; N], start: i32, goal: i32,
                     parent: &mut [i32; N]) -> bool {
    /* File circulaire statique */
    let mut q: [i32; N];
    let mut vis: [u8; N];

    /* Init q/vis/parent */
    for i in 0..N {
        q[i as usize] = 0;
        vis[i as usize] = 0;
        parent[i as usize] = -1;
    }

    let mut head: i32 = 0;
    let mut tail: i32 = 0;

    /* Enqueue start */
    q[tail as usize] = start; tail = (tail + 1) % N;
    vis[start as usize] = 1;

    /* Déplacements 4-voisins */
    let dx: [i32; 4] = [1, -1, 0, 0];
    let dy: [i32; 4] = [0, 0, 1, -1];

    while head != tail {
        let u = q[head as usize]; head = (head + 1) % N;
        if u == goal { return true; }

        let ux = u % W;
        let uy = u / W;

        for k in 0..4 {
            let vx = ux + dx[k as usize];
            let vy = uy + dy[k as usize];
            if !in_bounds(vx, vy) { continue; }

            let v = idx(vx, vy);
            let cell = grid[v as usize];

            if cell == C_WALL { continue; }
            if vis[v as usize] != 0 { continue; }

            vis[v as usize] = 1;
            parent[v as usize] = u;

            /* enqueue */
            q[tail as usize] = v;
            tail = (tail + 1) % N;
        }
    }
    return false;
}

/* --- Reconstruit le chemin in-place avec '*' ----------------------------- */

fn overlay_path(grid: &mut [u8; N], parent: &[i32; N], start: i32, goal: i32) -> i32 {
    let mut len: i32 = 0;
    let mut cur: i32 = goal;

    if parent[cur as usize] == -1 && cur != start { return 0; }

    while cur != -1 && cur != start {
        if grid[cur as usize] == C_FREE {
            grid[cur as usize] = C_P;
            len = len + 1;
        }
        cur = parent[cur as usize];
    }
    return len;
}

/* --- Utilitaires d’affichage -------------------------------------------- */

fn print_grid(grid: &[u8; N]) {
    for y in 0..H {
        for x in 0..W {
            putc(grid[idx(x, y) as usize]);
        }
        println("");
    }
}

/* putc pour les 5 symboles utilisés, sinon '?' */
fn putc(b: u8) {
    if b == C_WALL { print("#"); return; }
    if b == C_FREE { print("."); return; }
    if b == C_S    { print("S"); return; }
    if b == C_E    { print("E"); return; }
    if b == C_P    { print("*"); return; }
    print("?"); /* inconnu */
}

/* Impression d’un entier signé en base 10 sans allocation */
fn println_i32(x: i32) {
    let mut buf: [u8; 32]; /* assez pour i32 min */
    let n = i32_to_ascii(x, &mut buf);
    for i in 0..n { putc(buf[i as usize]); }
    println("");
}

/* Convertit i32 -> suite d’octets ASCII dans buf, retourne la longueur */
fn i32_to_ascii(mut v: i32, out: &mut [u8; 32]) -> i32 {
    if v == 0 { out[0] = 48; return 1; }
    let mut neg: bool = false;
    if v < 0 {
        neg = true;
        /* attention à -2^31 : convertir via i64 si ton impl le permet.
           Ici on traite simplement en ajoutant un décalage minimal. */
        v = -v;
    }
    let mut tmp: [u8; 16];
    let mut tlen: i32 = 0;
    while v > 0 {
        let d = (v % 10) as u8;
        tmp[tlen as usize] = 48 + d;
        tlen = tlen + 1;
        v = v / 10;
    }
    let mut k: i32 = 0;
    if neg {
        out[k as usize] = 45; /* '-' */
        k = k + 1;
    }
    /* reverse */
    let mut i: i32 = tlen - 1;
    while i >= 0 {
        out[k as usize] = tmp[i as usize];
        k = k + 1;
        i = i - 1;
    }
    return k;
}

/* --- Entrée principale --------------------------------------------------- */

fn main() -> i32 {
    let mut grid: [u8; N];
    let mut parent: [i32; N];

    for i in 0..N { grid[i as usize] = C_Q; parent[i as usize] = -1; }

    make_grid(&mut grid);

    /* Localiser S et E */
    let mut start: i32 = -1;
    let mut goal:  i32 = -1;
    for y in 0..H {
        for x in 0..W {
            let v = idx(x, y);
            let c = grid[v as usize];
            if c == C_S { start = v; }
            if c == C_E { goal  = v; }
        }
    }

    if start == -1 || goal == -1 {
        println("Erreur: S ou E introuvable.");
        print_grid(&grid);
        return 1;
    }

    let found = bfs_shortest_path(&grid, start, goal, &mut parent);
    if !found {
        println("Aucun chemin trouvé.");
        print_grid(&grid);
        return 0;
    }

    let steps = overlay_path(&mut grid, &parent, start, goal);

    grid[start as usize] = C_S;
    grid[goal  as usize] = C_E;

    println("Chemin trouvé.");
    print_grid(&grid);
    println("Longueur (cases marquées '*') = ");
    println_i32(steps);

    return 0;
}

/* --- I/O de base attendue par l’environnement Vitte ----------------------
   Les fonctions print/println sont supposées fournies par la runtime.
   Si besoin, mappez-les vers vos primitives (putchar, write, etc.).
--------------------------------------------------------------------------- */
fn print(s: str)   { /* fournie par la std/runtime */ }
fn println(s: str) { /* fournie par la std/runtime */ }