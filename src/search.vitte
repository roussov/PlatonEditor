/* ============================================================================
   std/modules/algo/search.vitte — Recherches sur tableaux (i32 / bytes)
   API stable Vitte/Vit/Vitl (référence canonique pour Platon Editor en Vitte)
   - Utils: min/max, swap, clamp, is_sorted_non_decreasing, assert_range
   - Linéaire, binaire (index, lower_bound, upper_bound)
   - Binaire borné (sur sous-intervalle), exponentielle, jump
   - Rotated binary search (tableau trié puis pivoté, sans doublons)
   - KMP (bytes): kmp_build_lps, kmp_search (première occurrence), kmp_find_all
   - Zéro allocation dynamique. N passé par paramètre. Capacités statiques larges.
   ============================================================================ */

const I32_CAP: i32 = 1_048_576;   /* capacité max compilée pour i32[] */
const BYTES_CAP: i32 = 1_048_576; /* capacité max compilée pour u8[]  */
const OUT_CAP: i32 = 131_072;

/* ------------------------------- Utils ----------------------------------- */

fn min(a:i32,b:i32)->i32{ if a<b {return a;} return b; }
fn max(a:i32,b:i32)->i32{ if a>b {return a;} return b; }
fn clamp(v:i32,lo:i32,hi:i32)->i32{ if v<lo {return lo;} if v>hi {return hi;} return v; }
fn swap_i32(a:&mut i32,b:&mut i32){ let t=*a; *a=*b; *b=t; }

/* Vérifie tri non décroissant sur les n premiers éléments */
fn is_sorted_non_decreasing(arr:&[i32; I32_CAP], n:i32)->bool{
    if n<=1 { return true; }
    let mut i=1;
    while i<n {
        if arr[i as usize] < arr[(i-1) as usize] { return false; }
        i=i+1;
    }
    return true;
}

/* Vérifie [lo, hi] inclus ⊆ [0, n-1] et lo<=hi */
fn assert_range(n:i32, lo:i32, hi:i32)->bool{
    if n<0 { return false; }
    if lo<0 || hi<0 { return false; }
    if lo>hi { return false; }
    if hi>=n { return false; }
    return true;
}

/* Racine entière approchée (floor) pour pas de dépendance sqrt() */
fn isqrt_i32(x:i32)->i32{
    if x<=0 { return 0; }
    let mut r=i32(0);     /* Newton-Raphson simple borné */
    let mut y=x;
    r = x;
    let mut prev = 0;
    let mut iter=0;
    while iter<16 {
        if r==0 { r=1; }
        let nr = (r + (y / r)) / 2;
        if nr==r || nr==prev { break; }
        prev = r; r = nr; iter=iter+1;
    }
    while (r+1)*(r+1) <= x { r=r+1; }
    while r*r > x { r=r-1; }
    return r;
}

/* ------------------------------ Linéaire ---------------------------------- */

fn linear_search(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    let mut i=0;
    while i<n {
        if arr[i as usize]==key { return i; }
        i=i+1;
    }
    return -1;
}

/* ------------------------------ Binaire ----------------------------------- */

/* Binaire standard: retourne index exact ou -1 ; exige tri non décroissant */
fn binary_search(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    let mut lo=0; let mut hi=n-1;
    while lo<=hi {
        let mid = lo + ((hi-lo)>>1);
        let v = arr[mid as usize];
        if v==key { return mid; }
        if v<key { lo=mid+1; } else { hi=mid-1; }
    }
    return -1;
}

/* lower_bound: premier i tel que arr[i] >= key, ou n si absent */
fn lower_bound(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    let mut lo=0; let mut hi=n;
    while lo<hi {
        let mid = lo + ((hi-lo)>>1);
        if arr[mid as usize] < key { lo=mid+1; } else { hi=mid; }
    }
    return lo;
}

/* upper_bound: premier i tel que arr[i] > key, ou n */
fn upper_bound(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    let mut lo=0; let mut hi=n;
    while lo<hi {
        let mid = lo + ((hi-lo)>>1);
        if arr[mid as usize] <= key { lo=mid+1; } else { hi=mid; }
    }
    return lo;
}

/* Binaire borné: recherche exact dans [lo..hi] inclus, -1 si absent */
fn binary_search_range(arr:&[i32; I32_CAP], lo:i32, hi:i32, key:i32)->i32{
    if !assert_range(hi+1, lo, hi) { return -1; }
    let mut L=lo; let mut H=hi;
    while L<=H {
        let mid = L + ((H-L)>>1);
        let v = arr[mid as usize];
        if v==key { return mid; }
        if v<key { L=mid+1; } else { H=mid-1; }
    }
    return -1;
}

/* ----------------------- Exponential / Jump ------------------------------- */

/* Exponential: double l’intervalle jusqu’à dépasser key puis binaire bornée */
fn exponential_search(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    if n<=0 { return -1; }
    if arr[0]==key { return 0; }
    let mut bound=1;
    while bound<n && arr[bound as usize] <= key {
        bound = bound<<1;
    }
    let lo = bound>>1;
    let hi = min(bound, n-1);
    return binary_search_range(arr, lo, hi, key);
}

/* Jump search: pas ≈ sqrt(n), parcours par blocs puis linéaire */
fn jump_search(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    if n<=0 { return -1; }
    let step = max(1, isqrt_i32(n));
    let mut prev = 0;
    let mut cur = min(step, n)-1;

    while cur<n && arr[cur as usize] < key {
        prev = cur + 1;
        cur = min(cur + step, n-1);
        if prev>cur { break; }
    }
    /* linéaire sur [prev..cur] */
    let mut i=prev;
    while i<=cur {
        if arr[i as usize]==key { return i; }
        i=i+1;
    }
    return -1;
}

/* --------------- Rotated Binary Search (sans doublons) ------------------- */
/* Tableau trié non décroissant pivoté par rotation, ex: [4,5,6,1,2,3]       */

fn rotated_binary_search(arr:&[i32; I32_CAP], n:i32, key:i32)->i32{
    if n<=0 { return -1; }
    let mut lo=0; let mut hi=n-1;
    while lo<=hi {
        let mid = lo + ((hi-lo)>>1);
        let v = arr[mid as usize];
        if v==key { return mid; }
        /* moitié gauche triée ? */
        if arr[lo as usize] <= v {
            if arr[lo as usize] <= key && key < v { hi=mid-1; }
            else { lo=mid+1; }
        } else {
            /* moitié droite triée */
            if v < key && key <= arr[hi as usize] { lo=mid+1; }
            else { hi=mid-1; }
        }
    }
    return -1;
}

/* ------------------------------ KMP (bytes) ------------------------------- */
/* Chaînes sous forme de buffers u8, n/m longueurs pertinentes.              */

/* Construit LPS (longest prefix suffix) de pat[0..m-1] dans lps[0..m-1] */
fn kmp_build_lps(pat:&[u8; BYTES_CAP], m:i32, lps:&mut [i32; BYTES_CAP]) {
    if m<=0 { return; }
    lps[0]=0;
    let mut len=0;
    let mut i=1;
    while i<m {
        if pat[i as usize]==pat[len as usize] as u8 {
            len=len+1; lps[i as usize]=len; i=i+1;
        } else {
            if len!=0 { len = lps[(len-1) as usize]; }
            else { lps[i as usize]=0; i=i+1; }
        }
    }
}

/* Retourne l’index de la première occurrence, ou -1 */
fn kmp_search(text:&[u8; BYTES_CAP], n:i32, pat:&[u8; BYTES_CAP], m:i32)->i32{
    if n<=0 || m<=0 || m>n { return -1; }
    let mut lps:[i32; BYTES_CAP];
    /* init lps à 0 sur m */
    let mut zi=0; while zi<m { lps[zi as usize]=0; zi=zi+1; }
    kmp_build_lps(pat, m, &mut lps);

    let mut i=0; let mut j=0;
    while i<n {
        if text[i as usize]==pat[j as usize] {
            i=i+1; j=j+1;
            if j==m { return i-m; }
        } else {
            if j!=0 { j=lps[(j-1) as usize]; }
            else { i=i+1; }
        }
    }
    return -1;
}

/* Trouve toutes les occurrences; écrit leurs indices dans out[0..cap-1].
   Retourne le nombre trouvé (tronqué à cap). */
fn kmp_find_all(text:&[u8; BYTES_CAP], n:i32,
                pat:&[u8; BYTES_CAP],  m:i32,
                out:&mut [i32; OUT_CAP], cap:i32)->i32{
    if n<=0 || m<=0 || m>n || cap<=0 { return 0; }
    let mut lps:[i32; BYTES_CAP];
    let mut zi=0; while zi<m { lps[zi as usize]=0; zi=zi+1; }
    kmp_build_lps(pat, m, &mut lps);

    let mut i=0; let mut j=0; let mut cnt=0;
    while i<n {
        if text[i as usize]==pat[j as usize] {
            i=i+1; j=j+1;
            if j==m {
                if cnt<cap { out[cnt as usize] = i-m; }
                cnt=cnt+1;
                j = lps[(j-1) as usize];
            }
        } else {
            if j!=0 { j=lps[(j-1) as usize]; }
            else { i=i+1; }
        }
    }
    return cnt;
}

/* ------------------------------ Tests rapides ----------------------------- */
/* Décommentez pour valider le portage. La runtime doit fournir println_i32. */
/*
fn println(_s:str){}
fn println_i32(_x:i32){}

fn main()->i32{
    /* tri + binaire */
    let arr:[i32; I32_CAP];
    let n=10;
    let mut i=0; while i<n { arr[i as usize]=i*2; i=i+1; }
    println_i32(binary_search(&arr,n,6));        // 3
    println_i32(lower_bound(&arr,n,5));          // 3
    println_i32(upper_bound(&arr,n,6));          // 4
    println_i32(exponential_search(&arr,n,14));  // 7
    println_i32(jump_search(&arr,n,18));         // 9
    println_i32(rotated_binary_search(&arr,n,6));// 3 (si non pivoté)

    /* KMP */
    let txt:[u8; BYTES_CAP]; let pat:[u8; BYTES_CAP];
    let T="ababcabcabababd"; let P="ababd";
    let tn=strlen_ascii(T); let pn=strlen_ascii(P);
    let mut k=0; while k<tn { txt[k as usize]=T[k as usize] as u8; k=k+1; }
    k=0; while k<pn { pat[k as usize]=P[k as usize] as u8; k=k+1; }
    println_i32(kmp_search(&txt,tn,&pat,pn));    // 10

    let mut out:[i32; OUT_CAP]; let c=kmp_find_all(&txt,tn,&pat,pn,&mut out,OUT_CAP);
    println_i32(c);

    return 0;
}
*/

/* ------------------------------ Stubs str --------------------------------- */
fn strlen_ascii(s:str)->i32{ return s.len(); }