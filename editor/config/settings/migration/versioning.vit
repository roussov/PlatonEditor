space platon.editor.config.settings.migration.versioning

<<< Settings Migration and Versioning Engine ULTRA MAX >>>
<<< Supports semantic versioning, step migrations, rollback safety, transactional upgrade >>>

form SemVersion {
    major : int
    minor : int
    patch : int
}

form MigrationStep {
    from_major : int
    from_minor : int
    from_patch : int
    to_major : int
    to_minor : int
    to_patch : int
}

form MigrationResult {
    success : bool
    migrated : bool
    old_version : SemVersion
    new_version : SemVersion
}

form VersionState {
    current : SemVersion
    target  : SemVersion
    migrations_applied : int
}

let version_state = VersionState {
    current: SemVersion { major: 1, minor: 0, patch: 0 },
    target:  SemVersion { major: 1, minor: 0, patch: 0 },
    migrations_applied: 0
}

<<< Compare semantic versions >>>

proc version_equal(a : SemVersion, b : SemVersion) -> bool {
    return a.major == b.major
        and a.minor == b.minor
        and a.patch == b.patch
}

proc version_less(a : SemVersion, b : SemVersion) -> bool {

    if a.major < b.major { return true }
    if a.major > b.major { return false }

    if a.minor < b.minor { return true }
    if a.minor > b.minor { return false }

    return a.patch < b.patch
}

<<< Begin migration transaction >>>

proc begin_migration() -> bool {
    <<< Real engine would snapshot layered store >>>
    return true
}

<<< Rollback migration >>>

proc rollback_migration(old_version : SemVersion) {
    set version_state.current = old_version
}

<<< Apply single migration step stub >>>

proc apply_step(step : MigrationStep) -> bool {

    <<< Real engine would transform settings keys/values here >>>

    set version_state.current = SemVersion {
        major: step.to_major,
        minor: step.to_minor,
        patch: step.to_patch
    }

    set version_state.migrations_applied =
        version_state.migrations_applied + 1

    return true
}

<<< Perform migration to target version >>>

proc migrate_to(target : SemVersion) -> MigrationResult {

    let old = version_state.current

    if version_equal(old, target) {
        return MigrationResult {
            success: true,
            migrated: false,
            old_version: old,
            new_version: old
        }
    }

    if not begin_migration() {
        return MigrationResult {
            success: false,
            migrated: false,
            old_version: old,
            new_version: old
        }
    }

    set version_state.target = target

    <<< Simulated single step migration >>>

    let step = MigrationStep {
        from_major: old.major,
        from_minor: old.minor,
        from_patch: old.patch,
        to_major: target.major,
        to_minor: target.minor,
        to_patch: target.patch
    }

    if not apply_step(step) {
        rollback_migration(old)

        return MigrationResult {
            success: false,
            migrated: false,
            old_version: old,
            new_version: old
        }
    }

    return MigrationResult {
        success: true,
        migrated: true,
        old_version: old,
        new_version: version_state.current
    }
}

<<< Force version set for testing >>>

proc force_version(major : int, minor : int, patch : int) {

    set version_state.current = SemVersion {
        major: major,
        minor: minor,
        patch: patch
    }
}

<<< Access current version >>>

proc current_version() -> SemVersion {
    return version_state.current
}

<<< Stress migration forward >>>

proc stress_migration(iterations : int) {

    let i = 0

    loop {
        if i >= iterations {
            break
        }

        migrate_to(SemVersion {
            major: 2,
            minor: 0,
            patch: 0
        })

        force_version(1, 0, 0)

        set i = i + 1
    }
}

<<< Stress version comparison >>>

proc stress_version_compare(iterations : int) {

    let i = 0

    loop {
        if i >= iterations {
            break
        }

        version_less(
            SemVersion { major: 1, minor: 0, patch: 0 },
            SemVersion { major: 2, minor: 0, patch: 0 }
        )

        set i = i + 1
    }
}