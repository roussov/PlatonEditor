space platon.editor.config.settings.engine.schema

# Settings Schema Engine ULTRA MAX# Strong typing, validation rules, defaults, constraints, versioned
form SchemaField {
    key : string
    type_name : string
    required : bool
    default_value : string
    min_int : int
    max_int : int
}

form ValidationResult {
    valid : bool
    reason : string
}

form SchemaState {
    version : int
    fields_count : int
}

const MAX_SCHEMA_FIELDS : int = 1024

let schema = SchemaState {
    version: 1,
    fields_count: 0
}

# Internal version bump
proc bump_schema_version() {
    schema.version = schema.version + 1
}

# Register schema field
proc register_field(field : SchemaField) -> bool {

    if schema.fields_count >= MAX_SCHEMA_FIELDS {
        return false
    }

    schema.fields_count = schema.fields_count + 1
    bump_schema_version()

    return true
}

# Validate int field
proc validate_int(field : SchemaField, value : int) -> ValidationResult {

    if value < field.min_int {
        return ValidationResult {
            valid: false,
            reason: "below.min"
        }
    }

    if value > field.max_int {
        return ValidationResult {
            valid: false,
            reason: "above.max"
        }
    }

    return ValidationResult {
        valid: true,
        reason: ""
    }
}

# Validate bool field
proc validate_bool(field : SchemaField, raw : string) -> ValidationResult {

    if raw == "true" or raw == "false" {
        return ValidationResult {
            valid: true,
            reason: ""
        }
    }

    return ValidationResult {
        valid: false,
        reason: "invalid.bool"
    }
}

# Generic field validation
proc validate_field(
    field : SchemaField,
    raw_value : string
) -> ValidationResult {

    if field.type_name == "int" {
# Real engine would parse safely        return validate_int(field, 0)
    }

    if field.type_name == "bool" {
        return validate_bool(field, raw_value)
    }

    return ValidationResult {
        valid: true,
        reason: ""
    }
}

# Apply default if missing
proc apply_default(field : SchemaField) -> string {
    return field.default_value
}

# Snapshot version access
proc current_schema_version() -> int {
    return schema.version
}

# Reset schema registry
proc reset_schema() {

    schema.fields_count = 0
    bump_schema_version()
}

# Stress field registration
proc stress_register_fields(iterations : int) {

    let i = 0

    loop {
        if i >= iterations {
            break
        }

        register_field(
            SchemaField {
                key: "editor.key",
                type_name: "bool",
                required: false,
                default_value: "false",
                min_int: 0,
                max_int: 0
            }
        )

        set i = i + 1
    }
}

# Stress validation
proc stress_validation(iterations : int) {

    let field = SchemaField {
        key: "editor.fontSize",
        type_name: "int",
        required: true,
        default_value: "12",
        min_int: 8,
        max_int: 72
    }

    let i = 0

    loop {
        if i >= iterations {
            break
        }

        validate_int(field, 16)

        set i = i + 1
    }
}