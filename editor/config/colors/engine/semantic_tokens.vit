space platon.editor.config.colors.engine.semantic

# ============================================================
# Semantic Token Types (LSP aligned)
# ============================================================

form SemanticToken {
    token_type : string
    modifiers  : int
}

# Bitmask modifiers
const MOD_DECLARATION : int = 1
const MOD_DEFINITION  : int = 2
const MOD_READONLY    : int = 4
const MOD_STATIC      : int = 8
const MOD_DEPRECATED  : int = 16
const MOD_ASYNC       : int = 32

# ============================================================
# Color model
# ============================================================

form Color {
    r : int
    g : int
    b : int
}

form SemanticStyle {
    fg : Color
    bold : bool
    italic : bool
    underline : bool
}

form ThemeSemantic {
    keyword : Color
    function : Color
    variable : Color
    type_name : Color
    string_lit : Color
    number_lit : Color
    comment : Color
    macro : Color
    operator : Color
    background : Color
}

# ============================================================
# Utilities
# ============================================================

proc pack_rgb(c : Color) -> int {
    return (c.r << 16) | (c.g << 8) | c.b
}

proc has_modifier(mask : int, flag : int) -> bool {
    return (mask & flag) != 0
}

# ============================================================
# Default Dark Semantic Theme
# ============================================================

proc default_dark_semantic() -> ThemeSemantic {
    return ThemeSemantic {
        keyword:     Color { r: 120, g: 160, b: 255 },
        function:    Color { r: 100, g: 200, b: 255 },
        variable:    Color { r: 220, g: 220, b: 220 },
        type_name:   Color { r: 150, g: 220, b: 150 },
        string_lit:  Color { r: 200, g: 180, b: 120 },
        number_lit:  Color { r: 180, g: 140, b: 255 },
        comment:     Color { r: 120, g: 130, b: 140 },
        macro:       Color { r: 255, g: 160, b: 120 },
        operator:    Color { r: 180, g: 180, b: 180 },
        background:  Color { r: 24, g: 26, b: 31 }
    }
}

# ============================================================
# Token Resolution
# ============================================================

proc resolve_semantic(token : SemanticToken, theme : ThemeSemantic) -> SemanticStyle {

    let base_color =
        if token.token_type == "keyword" {
            theme.keyword
        } else if token.token_type == "function" {
            theme.function
        } else if token.token_type == "variable" {
            theme.variable
        } else if token.token_type == "type" {
            theme.type_name
        } else if token.token_type == "string" {
            theme.string_lit
        } else if token.token_type == "number" {
            theme.number_lit
        } else if token.token_type == "comment" {
            theme.comment
        } else if token.token_type == "macro" {
            theme.macro
        } else {
            theme.operator
        }

    let bold = has_modifier(token.modifiers, MOD_DEFINITION)
    let italic = has_modifier(token.modifiers, MOD_STATIC)
    let underline = has_modifier(token.modifiers, MOD_DEPRECATED)

    return SemanticStyle {
        fg: base_color,
        bold: bold,
        italic: italic,
        underline: underline
    }
}

# ============================================================
# Render Preparation
# ============================================================

proc prepare_semantic_render(token : SemanticToken, theme : ThemeSemantic) -> int {
    let style = resolve_semantic(token, theme)
    return pack_rgb(style.fg)
}

# ============================================================
# Stress Resolver (benchmark helper)
# ============================================================

proc stress_resolve(count : int) {
    let theme = default_dark_semantic()
    let i = 0

    loop {
        if i >= count {
            break
        }

        resolve_semantic(
            SemanticToken {
                token_type: "variable",
                modifiers: MOD_DECLARATION | MOD_STATIC
            },
            theme
        )

        set i = i + 1
    }
}