space platon.editor.core.buffer.tests.buffer_test_4

pull platon.editor.core.buffer.piece_table.table as table
pull platon.editor.core.buffer.piece_table.snapshot as snapshot
pull platon.editor.core.buffer.piece_table.history as history
pull platon.editor.core.buffer.rope.rope_node as rope_node
pull platon.editor.core.buffer.rope.rope_split as rope_split
pull platon.editor.core.buffer.rope.rope_merge as rope_merge

<<< Buffer Integration Test 4 ULTRA MAX+++ >>>
<<< Cross-cycle regression, snapshot/history interleave, large sequence validation >>>


proc assert_true(cond : bool) {
    if not cond {
        panic("Assertion failed")
    }
}

proc assert_eq(a : int, b : int) {
    if a != b {
        panic("Assertion failed")
    }
}

<<< Deterministic RNG (repeatable CI mode) >>>

form Rng {
    seed : int
}

proc rng_new(seed : int) -> Rng {
    return Rng { seed: seed }
}

proc rng_next(r : Rng) -> Rng {
    set r.seed = (r.seed * 1664525 + 1013904223) % 2147483647
    return r
}

proc rng_val(r : Rng, max : int) -> [Rng] {

    if max <= 0 {
        return [r, 0]
    }

    set r = rng_next(r)

    let v = r.seed % max

    return [r, v]
}

<<< Massive mixed edit cycle test >>>

proc mixed_edit_cycle() {

    let te = table.new_engine()
    let pt = table.new("BASE")

    let se = snapshot.new()
    let h = history.new()

    let r = rng_new(2026)

    let i = 0

    loop {

        if i >= 800 {
            break
        }

        let r1 = rng_val(r, 4)
        set r = r1[0]
        let op = r1[1]

        if op == 0 {

            let r2 = rng_val(r, pt.total_length + 1)
            set r = r2[0]
            let pos = r2[1]

            set pt =
                table.insert(te, pt, pos, "X")

        } else if op == 1 and pt.total_length > 0 {

            let r3 = rng_val(r, pt.total_length)
            set r = r3[0]
            let pos2 = r3[1]

            set pt =
                table.delete(te, pt, pos2, 1)

        } else if op == 2 {

            set se =
                snapshot.create_snapshot(
                    se,
                    pt.pieces,
                    0
                )

        } else {

            set h = history.begin(h)

            set h =
                history.record(
                    h,
                    history.OperationKind.Insert,
                    pt.total_length,
                    1,
                    "Z"
                )

            set h = history.commit(h)
        }

        let material =
            table.materialize(pt)

        assert_eq(material.length, pt.total_length)

        set i = i + 1
    }

    assert_true(pt.total_length >= 0)
}

<<< Rope structural invariant regression >>>

proc rope_regression_test() {

    let rne = rope_node.new()
    let rme = rope_merge.new(3)
    let rse = rope_split.new()

    let root =
        rope_node.leaf(rne, "A")

    let i = 0
    let current = root

    loop {

        if i >= 1500 {
            break
        }

        let leaf =
            rope_node.leaf(rne, "B")

        set current =
            rope_merge.merge_full(
                rme,
                current,
                leaf
            )

        if i % 11 == 0 {

            let parts =
                rope_split.split_rebalanced(
                    rse,
                    current,
                    i % 7
                )

            set current =
                rope_merge.merge_full(
                    rme,
                    parts[0],
                    parts[1]
                )
        }

        let first =
            rope_node.char_at(current, 0)

        assert_true(first == "A")

        set i = i + 1
    }
}

<<< Snapshot rollback cascade test >>>

proc snapshot_rollback_cascade() {

    let te = table.new_engine()
    let pt = table.new("ROOT")

    let se = snapshot.new()

    set pt =
        table.insert(te, pt, 4, "1")

    set se =
        snapshot.create_snapshot(
            se,
            pt.pieces,
            0
        )

    set pt =
        table.insert(te, pt, 5, "2")

    set se =
        snapshot.create_snapshot(
            se,
            pt.pieces,
            1
        )

    set pt =
        table.insert(te, pt, 6, "3")

    let snap2 =
        snapshot.restore_snapshot(se, 2)

    set pt.pieces = snap2

    let txt =
        table.materialize(pt)

    assert_true(txt == "ROOT12")
}

<<< History saturation regression >>>

proc history_saturation_test() {

    let h = history.new()

    let i = 0

    loop {

        if i >= 500 {
            break
        }

        set h = history.begin(h)

        set h =
            history.record(
                h,
                history.OperationKind.Insert,
                i,
                1,
                "K"
            )

        set h = history.commit(h)

        set i = i + 1
    }

    assert_eq(history.undo_depth(h), 500)

    let j = 0

    loop {

        if j >= 500 {
            break
        }

        set h = history.undo(h)
        set j = j + 1
    }

    assert_eq(history.undo_depth(h), 0)
}

proc run_all_tests() {

    mixed_edit_cycle()
    rope_regression_test()
    snapshot_rollback_cascade()
    history_saturation_test()
}