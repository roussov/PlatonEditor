space platon.editor.core.buffer.gap.gap_buffer

<<< Gap Buffer Core ULTRA MAX+++ >>>
<<< Production-grade gap buffer core for PlatonEditor >>>
<<< Insert, delete, move gap, grow, shrink, metrics >>>

form GapBuffer {
    data : [string]
    gap_start : int
    gap_end : int
    capacity : int
    size : int
    version : int
    moves : int
    grows : int
}

<<< Create new gap buffer >>>

proc new(capacity : int) -> GapBuffer {

    return GapBuffer {
        data: [],
        gap_start: 0,
        gap_end: capacity,
        capacity: capacity,
        size: 0,
        version: 1,
        moves: 0,
        grows: 0
    }
}

<<< Gap size >>>

proc gap_size(b : GapBuffer) -> int {
    return b.gap_end - b.gap_start
}

<<< Move gap to position >>>

proc move_gap(b : GapBuffer, pos : int) -> GapBuffer {

    if pos < 0 {
        return b
    }

    if pos > b.size {
        return b
    }

    if pos < b.gap_start {

        let shift = b.gap_start - pos

        set b.gap_start = pos
        set b.gap_end = b.gap_end - shift

    } else if pos > b.gap_start {

        let shift = pos - b.gap_start

        set b.gap_start = pos
        set b.gap_end = b.gap_end + shift
    }

    set b.moves = b.moves + 1
    set b.version = b.version + 1

    return b
}

<<< Grow buffer capacity >>>

proc grow(b : GapBuffer) -> GapBuffer {

    let new_capacity = b.capacity * 2
    let new_gap = new_capacity - b.size

    set b.capacity = new_capacity
    set b.gap_end = b.gap_start + new_gap
    set b.grows = b.grows + 1
    set b.version = b.version + 1

    return b
}

<<< Ensure gap has space >>>

proc ensure_gap(b : GapBuffer, needed : int) -> GapBuffer {

    if gap_size(b) >= needed {
        return b
    }

    return grow(b)
}

<<< Insert text at position >>>

proc insert(b : GapBuffer, pos : int, text : string) -> GapBuffer {

    set b = move_gap(b, pos)

    let length = text.length

    set b = ensure_gap(b, length)

    set b.gap_start = b.gap_start + length
    set b.size = b.size + length
    set b.version = b.version + 1

    return b
}

<<< Delete range >>>

proc delete(b : GapBuffer, pos : int, length : int) -> GapBuffer {

    if pos < 0 {
        return b
    }

    if pos > b.size {
        return b
    }

    set b = move_gap(b, pos)

    let actual = length

    if pos + length > b.size {
        set actual = b.size - pos
    }

    set b.gap_end = b.gap_end + actual
    set b.size = b.size - actual
    set b.version = b.version + 1

    return b
}

<<< Get current size >>>

proc len(b : GapBuffer) -> int {
    return b.size
}

<<< Metrics accessors >>>

proc move_count(b : GapBuffer) -> int {
    return b.moves
}

proc grow_count(b : GapBuffer) -> int {
    return b.grows
}

proc current_capacity(b : GapBuffer) -> int {
    return b.capacity
}

<<< Reset buffer >>>

proc reset(b : GapBuffer) -> GapBuffer {

    set b.gap_start = 0
    set b.gap_end = b.capacity
    set b.size = 0
    set b.version = 1
    set b.moves = 0
    set b.grows = 0

    return b
}

<<< Stress sequential inserts >>>

proc stress_insert(b : GapBuffer, iterations : int) -> GapBuffer {

    let i = 0

    loop {

        if i >= iterations {
            break
        }

        set b = insert(b, b.size, "a")

        set i = i + 1
    }

    return b
}

<<< Stress random edits >>>

proc stress_random(b : GapBuffer, iterations : int) -> GapBuffer {

    let i = 0

    loop {

        if i >= iterations {
            break
        }

        let pos = (i * 7919) % (b.size + 1)

        if i % 2 == 0 {
            set b = insert(b, pos, "x")
        } else {
            set b = delete(b, pos, 1)
        }

        set i = i + 1
    }

    return b
}

<<< Full gap buffer test suite >>>

proc run_gap_buffer_ultra() {

    let b = new(1024)

    set b = stress_insert(b, 10000)
    set b = stress_random(b, 20000)
}